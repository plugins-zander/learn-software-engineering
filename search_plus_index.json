{"./":{"url":"./","title":"本书简介","keywords":"","body":""},"page/1010.html":{"url":"page/1010.html","title":"结构化设计","keywords":"","body":"结构化设计 "},"page/1011.html":{"url":"page/1011.html","title":"概述","keywords":"","body":"概述 1.1 软件危机 　　迄今为止，计算机系统已经经历了4个不同的发展阶段，但是，我们仍然没有彻底摆脱“软件危机”的困扰，软件已经成为限制计算机系统发展的瓶颈。 　　为了更有效地开发与维护软件，在20世纪60年代后期软件工作者开始认真研究消除软件危机的途径，从而形成了一门新兴的工程学科——计算机软件工程学(通常简称为软件工程)。 　　在20世纪60年代中期以前，是计算机系统发展的早期时代，通用硬件相当普遍，软件却是为每个具体应用而专门编写的。 　　这时的软件通常是规模较小的程序，编写者和使用者往往是同一个(或同一组)人。这种个体化的软件环境，使得软件设计通常是在人们头脑中进行的一个隐含的过程，除了程序清单之外，没有其他文档资料保存下来。 　　从20世纪60年代中期到70年代中期，是计算机系统发展的第二代时期，这个时期的一个重要特征是出现了“软件作坊”，广泛使用产品软件。 　　 “软件作坊”基本上仍然沿用早期形成的个体化软件开发方法。 　　随着计算机应用的日益普及，软件数量急剧膨胀。要求软件： 　　　　在程序运行时发现的错误必须设法改正； 　　　　用户有了新的需求时必须相应地修改程序； 　　　　硬件或操作系统更新时，通常需要修改程序以适应新的环境。 　　上述种种软件维护工作，以令人吃惊的比例耗费资源。更严重的是，许多程序的个体化特性使得它们最终成为不可维护的。 　　 “软件危机”就这样开始出现了!1968年北大西洋公约组织的计算机科学家在联邦德国召开国际会议，讨论软件危机问题，在这次会议上正式提出并使用了“软件工程”这个名词，一门新兴的工程学科就此诞生了。 1.1.1 软件危机的介绍 软件危机：是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。 这些问题绝不仅仅是不能正常运行的软件才具有的，实际上，几乎所有软件都不同程度地存在这些问题。 概括地说，软件危机包含下述两方面的问题： 　　　　如何开发软件，以满足对软件日益增长的需求； 　　　　如何维护数量不断膨胀的已有软件。 具体地说，软件危机主要有以下一些典型表现。 (1)对软件开发成本和进度的估计常常很不准确。 实际成本比估计成本有可能高出一个数量级，实际进度比预期进度拖延几个月甚至几年的现象并不罕见。这种现象降低了软件开发组织的信誉。而为了赶进度和节约成本所采取的一些权宜之计又往往损害了软件产品的质量，从而不可避免地会引起用户的不满。 (2) 用户对“已完成的”软件系统不满意的现象经常发生。 软件开发人员常常在对用户要求只有模糊的了解，甚至对所要解决的问题还没有确切认识的情况下，就匆忙着手编写程序。由于和用户之间的信息交流不充分，必然导致最终的产品不符合用户的实际需要。 (3) 软件产品的质量往往靠不住。 软件质量保证技术(审查、复审和测试)没有坚持不懈地应用到软件开发的全过程中，导致软件产品发生质量问题。 (4) 软件常常是不可维护的。 很多程序中的错误是非常难改正的，无法使这些程序适应新的硬件环境，也不能根据用户的需要在原有程序中增加一些新的功能。 “可重用的软件”还是一个没有完全做到的、正在努力追求的目标，人们仍然在重复开发类似的或基本类似的软件。 (5) 软件通常没有适当的文档资料。 计算机软件不仅仅是程序，还应该有一整套文档资料。这些文档资料应该是在软件开发过程中产生出来的，而且应该是“最新式的”(即和程序代码完全一致的)。 软件开发组织的管理人员可以使用这些文档资料作为“里程碑”，来管理和评价软件开发工程的进展状况； 软件开发人员可以利用它们作为通信工具，在软件开发过程中准确地交流信息； 对于软件维护人员而言，这些文档资料更是必不可少的。缺乏必要的文档资料或者文档资料不合格，必然给软件开发和维护带来许多严重的困难和问题。 (6) 软件成本在计算机系统总成本中所占的比例逐年上升。 由于微电子学技术的进步和生产自动化程度不断提高，硬件成本逐年下降，然而软件开发需要大量人力，软件成本随着通货膨胀以及软件规模和数量的不断扩大而持续上升。美国在1985年软件成本大约已占计算机系统总成本的90%。 (7) 软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势，软件产品“供不应求” 。 1.1.2 产生软件危机的原因 在软件开发和维护的过程中存在这么多严重问题， 一方面与软件本身的特点有关， 一方面和软件开发与维护的方法不正确有关。 管理和控制软件开发过程相当困难。 软件不同于硬件，缺乏“可见性”，在写出程序代码并在计算机上试运行之前，软件开发过程的进展情况较难衡量，软件的质量也较难评价。 软件较难维护 软件在运行过程中不会因为使用时间过长而被“用坏”，运行中发现的错误 ，很可能是在开发时期引入的在测试阶段没能检测出来的错误，需要改正或修改原来的设计，使得软件较难维护。 软件不同于一般程序，其显著特点是规模庞大，而且，程序的复杂性随着程序规模的增加呈指数上升。 为了在预定时间内开发出规模庞大的软件，必须由许多人分工合作，然而，如何保证每个人完成的工作合在一起确实能构成一个高质量的大型软件系统，是一个极端复杂困难的问题，不仅涉及许多技术问题，更重要的是必须有严格而科学的管理。 软件专业人员对软件开发和维护的错误的认识和作法。 软件本身独有的特点确实给开发和维护带来一些客观困难，但是人们在开发和使用计算机系统的长期实践中，也确实积累和总结出了许多成功的经验。 如果坚持不懈地使用正确的方法，许多困难是完全可以克服的。 但是，目前相当多的软件专业人员对软件开发和维护还有不少糊涂观念，在实践过程中或多或少地采用了错误的方法和技术，这是出现软件危机的主要原因。 这些错误认识和作法的形成，可以归因于在计算机系统发展的早期阶段软件开发的个体化特点。 错误的认识和作法主要表现为忽视软件需求分析的重要性，认为软件开发就是写程序并设法使之运行，轻视软件维护等。 对用户要求没有完整准确的认识就匆忙着手编写程序是许多软件开发工程失败的主要原因之一。 只有用户才真正了解他们自己的需要，但是许多用户在开始时并不能准确具体地叙述他们的需要，软件开发人员需要做大量深入细致的调查研究工作，反复多次地和用户交流信息，才能真正全面、准确、具体地了解用户的要求。急于求成，仓促上阵，对用户要求没有正确认识就匆忙着手编写程序，最终必然失败。 事实上，越早开始写程序，完成它所需要用的时间往往越长。 ​ 一个软件从定义、开发、使用和维护，直到最终被废弃，要经历一个漫长的时期。通常把软件经历的这个漫长的时期称为生命周期。 ​ 软件开发最初的工作应是问题定义，也就是确定要求解决的问题是什么； ​ 然后要进行可行性研究，决定该问题是否存在一个可行的解决办法； ​ 接下来应该进行需求分析，也就是深入具体地了解用户的要求，在所要开发的系统(目标系统)必须做什么这个问题上和用户取得完全一致的看法。 ​ 经过上述软件定义时期的准备工作才能进入开发时期。 在开发时期首先需要对软件进行设计(分为概要设计和详细设计两个阶段)，然后才能进入编写程序的阶段，程序编写完之后还必须经过大量的测试工作(需要的工作量通常占软件开发全部工作量的40%～50%)才能最终交付使用。 所以，编写程序只是软件开发过程中的一个阶段，而且在典型的软件开发工程中，编写程序所需的工作量只占软件开发全部工作量的10%～20%。 程序只是完整的软件产品的一个组成部分，在软件生命周期的每个阶段都要得出最终产品的一个或几个组成部分(这些组成部分通常以文档资料的形式存在)。 因此，一个软件产品必须由一个完整的配置组成，软件配置主要包括程序、文档和数据等成分。必须清除只重视程序而忽视软件配置其余成分的糊涂观念。 　　作好软件定义时期的工作，是降低软件成本提高软件质量的关键。在软件开发的不同阶段进行修改需要付出的代价是很不相同的。 早期引入变动，涉及的面较少，因而代价也比较低； 　　在开发的中期，软件配置的许多成分已经完成，引入一个变动要对所有已完成的配置成分都做相应的修改，不仅工作量大，而且逻辑上也更复杂，因此付出的代价剧增； 　　在软件“已经完成”时再引入变动，当然需要付出更高的代价。根据美国一些软件公司的统计资料，在后期引入一个变动比在早期引入相同变动所需付出的代价高2～3个数量级。图1.1定性地描绘了在不同时期引入一个变动需要付出的代价的变化趋势。 通过上面的论述不难认识到，轻视维护是一个最大的错误。 许多软件产品的使用寿命长达10年甚至20年，在这样漫长的时期中 　　必须改正使用过程中发现的每一个潜伏的错误； 　　当环境变化时（例如硬件或系统软件更新换代）还必须相应地修改软件以适应新的环境； 　　经常改进或扩充原来的软件以满足用户不断变化的需要。 所有这些改动都属于维护工作，而且是在软件已经完成之后进行的。因此维护是极端艰巨复杂的工作，需要花费很大代价。 统计数据表明，实际上用于软件维护的费用占软件总费用的55%~70%。软件工程学的一个重要目标就是提高软件的可维护性，减少软件维护的代价。 1.1.3 消除软件危机的途径 为了消除软件危机，首先应该对计算机软件有一个正确的认识。 应该彻底消除在计算机系统早期发展阶段形成的“软件就是程序”的错误观念。 一个软件必须由一个完整的配置组成，事实上，软件是程序、数据及相关文档的完整集合。其中， 程序：是能够完成预定功能和性能的可执行的指令序列； 数据：是使程序能够适当地处理信息的数据结构； 文档：是开发、使用和维护程序所需要的图文资料。 1983年IEEE为软件下的定义是： 计算机程序、方法、规则、相关的文档资料以及在计算机上运行程序时所必需的数据。 虽然表面上看来在这个定义中列出了软件的5个配置成分，但是，方法和规则通常是在文档中说明并在程序中实现的。 更重要的是，必须充分认识到软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。 　　应该推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法，尽快消除在计算机系统早期发展阶段形成的一些错误概念和做法。 　　应该开发和使用更好的软件工具。 在软件开发的每个阶段都有许多繁琐重复的工作需要做，在适当的软件工具辅助下，开发人员可以把这类工作做得既快又好。 如果把各个阶段使用的软件工具有机地集合成一个整体，支持软件开发的全过程，则称为软件工程支撑环境。 总之，为了解决软件危机，既要有技术措施(方法和工具)，又要有必要的组织管理措施。 软件工程正是从管理和技术两方面研究如何更好地开发和维护计算机软件的一门新兴学科。 1.2 软件工程 1.2.1 软件工程的介绍 概括地说， 软件工程：是指导计算机软件开发和维护的一门工程学科。 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。 人们曾经给软件工程下过许多定义，下面给出两个典型的定义。 1968年在第一届NATO会议上曾经给出了软件工程的一个早期定义：“软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。” 这个定义不仅指出了软件工程的目标是经济地开发出高质量的软件，而且强调了软件工程是一门工程学科，它应该建立并使用完善的工程原理。 1993年IEEE进一步给出了一个更全面更具体的定义：“软件工程是： ①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件； ②研究①中提到的途径。” 虽然软件工程的不同定义使用了不同词句，强调的重点也有差异，但是，人们普遍认为软件工程具有下述的本质特性。 \\1. 软件工程关注于大型程序的构造 “大”与“小”的分界线并不十分清晰。通常把一个人在较短时间内写出的程序称为小型程序，而把多人合作用时半年以上才写出的程序称为大型程序。传统的程序设计技术和工具是支持小型程序设计的，不能简单地把这些技术和工具用于开发大型程序。 事实上，在此处使用术语“程序”并不十分恰当，现在的软件开发项目通常构造出包含若干个相关程序的“系统”。 \\2. 软件工程的中心课题是控制复杂性 通常，软件所解决的问题十分复杂，以致不能把问题作为一个整体通盘考虑。 人们不得不把问题分解，使得分解出的每个部分是可理解的，而且各部分之间保持简单的通信关系。 用这种方法并不能降低问题的整体复杂性，但是却可使它变成可以管理的。 注意，许多软件的复杂性主要不是由问题的内在复杂性造成的，而是由必须处理的大量细节造成的。 \\3. 软件经常变化 绝大多数软件都模拟了现实世界的某一部分。现实世界在不断变化，软件为了不被很快淘汰，必须随着所模拟的现实世界一起变化。因此，在软件系统交付使用后仍然需要耗费成本，而且在开发过程中必须考虑软件将来可能的变化。 \\4. 开发软件的效率非常重要 目前，社会对新应用系统的需求超过了人力资源所能提供的限度，软件供不应求的现象日益严重。因此，软件工程的一个重要课题就是，寻求开发与维护软件的更好更有效的方法和工具。 \\5. 和谐地合作是开发软件的关键 软件处理的问题十分庞大，必须多人协同工作才能解决这类问题。 为了有效地合作，必须明确地规定每个人的责任和相互通信的方法。为了迫使大家遵守规定，应该运用标准和规程。通常，可以用工具来支持这些标准和规程。 总之，纪律是成功地完成软件开发项目的一个关键。 \\6. 软件必须有效地支持它的用户 软件提供的功能应该能有效地协助用户完成他们的工作。因此，仅仅用正确的方法构造系统还不够，还必须构造出正确的系统。 有效地支持用户意味着必须仔细地研究用户，以确定适当的功能需求、可用性要求及其他质量要求(例如：可靠性、响应时间等)。 有效地支持用户还意味着，软件开发不仅应该提交软件产品，而且应该写出用户手册和培训材料，此外，还必须注意建立使用新系统的环境。 \\7. 在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品。 软件工程师是诸如Java程序设计、软件体系结构、测试或统一建模语言(UML)等方面的专家，他们通常并不是图书馆管理、航空控制或银行事务等领域的专家，但是他们却不得不为这些领域开发应用系统。 缺乏应用领域的相关知识，是软件开发项目出现问题的常见原因。 ​ 软件工程的基本原理共7条， 这7条原理互相独立，其中任意6条原理的组合都不能代替另一条原理，因此，它们是缺一不可的最小集合； 这7条原理又是相当完备的，人们虽然不能用数学方法严格证明它们是一个完备的集合，但是，可以证明在此之前已经提出的100多条软件工程原理都可以由这7条原理的任意组合蕴含或派生。 \\1. 用分阶段的生命周期计划严格管理 经统计发现，在不成功的软件项目中有一半左右是由于计划不周造成的，可见把建立完善的计划作为第一条基本原理是吸取了前人的教训而提出来的。 在软件开发与维护的漫长的生命周期中，需要完成许多性质各异的工作。这条基本原理意味着，应该把软件生命周期划分成若干个阶段，并相应地制定出切实可行的计划，然后严格按照计划对软件的开发与维护工作进行管理。 不同层次的管理人员都必须严格按照计划各尽其职地管理软件开发与维护工作，绝不能受客户或上级人员的影响而擅自背离预定计划。 \\2. 坚持进行阶段评审 软件的质量保证工作不能等到编码阶段结束之后再进行。理由： 第一，大部分错误是在编码之前造成的，例如，根据Boehm等人的统计，设计错误占软件错误的63%，编码错误仅占37%； 第二，错误发现与改正得越晚，所需付出的代价也越高。因此，在每个阶段都进行严格的评审，以便尽早发现在软件开发过程中所犯的错误，是一条必须遵循的重要原则。 \\3. 实行严格的产品控制 在软件开发过程中改变需求是难免的，只能依靠科学的产品控制技术来顺应这种要求。当改变需求时，为了保持软件各个配置成分的一致性，必须实行严格的产品控制，其中主要是实行基准配置管理。 所谓基准配置又称为基线配置，它们是经过阶段评审后的软件配置成分。基准配置管理也称为变动控制：一切有关修改软件的建议，特别是涉及到对基准配置的修改建议，都必须按照严格的规程进行评审，获得批准以后才能实施修改。绝对不能谁想修改软件，就随意进行修改。 \\4. 采用现代程序设计技术 研究各种新的程序设计技术，并进一步研究各种先进的软件开发与维护技术。 实践表明，采用先进的技术不仅可以提高软件开发和维护的效率，而且可以提高软件产品的质量。 \\5. 结果应能清楚地审查 软件产品是看不见摸不着的逻辑产品。软件开发人员(或开发小组)的工作进展情况可见性差，难以准确度量，从而使得软件产品的开发过程比一般产品的开发过程更难于评价和管理。 为了提高软件开发过程的可见性，更好地进行管理，应该根据软件开发项目的总目标及完成期限，规定开发组织的责任和产品标准，从而使得所得到的结果能够清楚地审查。 \\6. 开发小组的人员应该少而精 开发小组人员的素质和数量是影响软件产品质量和开发效率的重要因素。 素质高的人员的开发效率比素质低的人员的开发效率可能高几倍至几十倍，而且素质高的人员所开发的软件中的错误明显少于素质低的人员所开发的软件中的错误。 此外，随着开发小组人员数目的增加，因为交流情况讨论问题而造成的通信开销也急剧增加。 因此，组成少而精的开发小组是软件工程的一条基本原理。 \\7. 承认不断改进软件工程实践的必要性 遵循上述6条基本原理，就能够按照当代软件工程基本原理实现软件的工程化生产，但是，仅有上述6条原理并不能保证软件开发与维护的过程能赶上时代前进的步伐，能跟上技术的不断进步。 因此，把承认不断改进软件工程实践的必要性作为软件工程的第7条基本原理。按照这条原理，不仅要积极主动地采纳新的软件技术，而且要注意不断总结经验。 1.2.3 软件工程方法学 ​ 软件工程包括技术和管理两方面的内容，是技术与管理紧密结合所形成的工程学科。 管理：就是通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。在软件工程领域中，这两个术语的含义基本相同。 软件工程方法学包含3个要素： 方法、工具和过程。 方法：是完成软件开发的各项任务的技术方法，回答“怎样做”的问题； 工具：是为运用方法而提供的自动的或半自动的软件工程支撑环境； 过程：是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。 ​ 目前使用得最广泛的软件工程方法学，分别是传统方法学和面向对象方法学。 \\1. 传统方法学 传统方法学：也称为生命周期方法学或结构化范型。 它采用结构化技术(结构化分析、结构化设计和结构化实现)来完成软件开发的各项任务。 这种方法学把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。 　目前，传统方法学仍然是人们在开发软件时使用得十分广泛的软件工程方法学。 此外，要全面了解面向对象方法学，先要了解传统方法学。 传统方法学优点（生命周期方法学或结构化范型） 把软件生命周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员分工协作，从而降低了整个软件开发工程的困难程度； 在每个阶段结束之前都从技术和管理两个角度进行严格的审查，保证了软件的质量，特别是提高了软件的可维护性。 总之，采用生命周期方法学可以大大提高软件开发的成功率，软件开发的生产率也能明显提高。 \\2. 面向对象方法学 当软件规模庞大，或者对软件的需求是模糊的，或软件需求会随时间而变化的时候，使用传统方法学开发软件往往不成功。 此外，使用传统方法学开发出的软件，维护起来仍然很困难。 原因： 这种技术要么面向行为(即对数据的操作)，要么面向数据，把数据和操作人为地分离成两个独立的部分，自然会增加软件开发与维护的难度。 面向对象方法学具有下述4个要点。 (1) 把对象(object)作为融合了数据及在数据上的操作行为的统一的软件构件。用对象分解取代了传统方法的功能分解。 (2) 把所有对象都划分成类(class)。 (3) 父类与子类的继承关系。 把若干个相关类组成一个层次结构的系统，下层派生类自动拥有上层基类中定义的数据和操作。 (4) 对象彼此间仅能通过发送消息互相联系。 对象的所有私有信息都被封装在该对象内，不能从外界直接访问，这就是通常所说的封装性。 面向对象方法学优点 面向对象方法学的出发点和基本原则，是尽量模拟人类习惯的思维方式，从一般到特殊，从特殊到一般，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程。传统方法学强调自顶向下顺序地完成软件开发的各阶段任务。事实上，人类认识的过程，是一个渐进的过程，经过多次反复才能逐步深化。 运用面向对象方法学的开发软件，最终的软件产品由许多较小的、基本上独立的对象组成，降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作。 软件重用。对象是相对独立的实体，容易在以后的软件产品中重复使用。 继承性和多态性，进一步提高了面向对象软件的可重用性。 1.3 软件生命周期 软件生命周期：由软件定义、软件开发和运行维护，直到最终被废弃所经历的时期。 每个时期又进一步划分成若干个阶段。 软件定义时期的任务是： 　　确定软件开发工程必须完成的总目标； 　　确定工程的可行性； 　　导出实现工程总目标应该采用的策略及系统必须完成的功能； 　　估计完成该项工程需要的资源和成本，制定工程进度表。 这个时期的工作又称为系统分析，由系统分析员负责完成。 这个时期进一步划分成3个阶段： 　　问题定义、可行性研究和需求分析。 开发时期的任务是： 设计和实现在前一个时期定义的软件，它通常由下述4个阶段组成： 总体设计，详细设计，编码和单元测试，综合测试。 其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。 维护时期的主要任务是： 使软件持久地满足用户的需要。具体地说： 当软件在使用过程中发现错误时应该加以改正； 当环境改变时应该修改软件以适应新的环境； 当用户有新要求时应该及时改进软件以满足用户的新需要。 维护时期不再进一步划分阶段。 生命周期每个阶段的基本任务。 问题定义 关键问题是：“要解决的问题是什么?” 弄清楚 可行性研究 关键问题是：“对于上一个阶段所确定的问题有行得通的解决办法吗?” 任务：探索这个问题是否值得去解，是否有可行的解决办法。 不是具体解决问题。 需求分析 主要是确定目标系统必须具备哪些功能。 得出经过用户确认的系统逻辑模型。通常用数据流图、数据字典和简要的算法表示。 任务：是用正式文档准确地记录对目标系统的需求，这份文档通常称为规格说明书(specification)。 总体设计 关键问题是：“以概括的方式，应该怎样实现目标系统?” 总体设计又称为概要设计。 主要任务之一：制定出实现最佳方案的详细计划。 主要任务之二：设计程序的体系结构，确定程序由哪些模块组成以及模块间的关系。 ​ 软件设计的一条基本原理就是，程序应该模块化，一个程序应该由若干个规模适中的模块按合理的层次结构组织而成。 详细设计 详细设计阶段的任务就是把解法具体化。 任务： 设计出程序的详细规格说明，其作用很类似于工程蓝图，它们应该包含必要的细节。 具体地说： 详细地设计每个模块，确定实现模块功能所需要的算法和数据结构。 详细设计也称为模块设计， 还不是编写程序 编码和单元测试 关键任务：写出正确的容易理解、容易维护的程序模块。 综合测试 关键任务:通过各种类型的测试(及相应的调试)使软件达到预定的要求。 单元测试，查找各模块在功能和结构上存在的问题并加以纠正 组装测试，将已测试过的模块按一定顺序组装起来 按规定的各项需求，逐项进行有效性测试，决定已开发的软件是否合格，能否交付用户使用 软件维护 关键任务：通过各种必要的维护活动使系统持久地满足用户的需要。 通常有4类维护活动： 改正性维护：诊断和改正在使用过程中发现的软件错误； 适应性维护：修改软件以适应环境的变化； 完善性维护：根据用户的要求改进或扩充软件使它更完善； 预防性维护：修改软件为将来的维护活动预先做准备。 每一项维护活动都要经过： 提出维护要求(或报告问题)，分析维护要求，提出维护方案，审批维护方案，确定维护计划，修改软件设计，修改程序，测试程序，复查验收等一系列步骤，实质上是经历了一次压缩和简化了的软件定义和开发的全过程。 每一项维护活动都应该准确地记录下来，作为正式的文档资料加以保存。 1.4 软件过程 ​ 软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。 过程定义了运用方法的顺序、应该交付的文档资料、为保证软件质量和协调变化所需要采取的管理措施，以及标志软件开发各个阶段任务完成的里程碑。 通常使用生命周期模型简洁地描述软件过程。生命周期模型规定了把生命周期划分成哪些阶段及各个阶段的执行顺序，因此，也称为过程模型。 1.4.1 瀑布模型 ​ 在20世纪80年代之前，瀑布模型一直是惟一被广泛采用的生命周期模型，现在它仍然是软件工程中应用得最广泛的过程模型。 传统软件工程方法学的软件过程，基本上可以用瀑布模型来描述。 图1.2所示为传统的瀑布模型。 按照传统的瀑布模型开发软件，有下述的几个特点。 阶段间具有顺序性和依赖性 这个特点有两重含义： ①必须等前一阶段的工作完成之后，才能开始后一阶段的工作； ②前一阶段的输出文档就是后一阶段的输入文档。 \\2. 推迟实现的观点 对于规模较大的软件项目来说，往往编码开始得越早最终完成开发工作所需要的时间反而越长。 \\3. 质量保证的观点 每个阶段都应坚持两个重要做法： （1） 每个阶段都必须完成规定的文档。 （2） 每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。 ​ 传统的瀑布模型过于理想化了，事实上，人在工作过程中不可能不犯错误。 因此，实际的瀑布模型是带“反馈环”的，如图1.3所示。 ​ 当在后面阶段发现前面阶段的错误时，需要沿反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。 瀑布模型有许多优点： 强迫开发人员采用规范的方法； 严格地规定了每个阶段必须提交的文档； 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。 遵守瀑布模型的文档约束，将使软件维护变得比较容易一些。 文档驱动。 瀑布模型的缺点： 文档驱动 用户仅仅通过写在纸上的静态的规格说明，很难全面正确地认识动态的软件产品。 　一旦用户开始使用最终系统，并对系统有更多的学习以后，观点会发生很大的变化。用户的这种变化常常是无法预测的。 最终产品更多的反映用户在项目开始时的需求，而不是最后的需求。导致最终开发出的软件产品不满足用户需求。 1.4.2 快速原型模型 所谓快速原型：是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。 如图1.4所示 ​ 快速原型模型的第一步是快速建立一个能反映用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解目标系统的概貌。 用户试用原型系统之后 　　提出许多修改意见， 　　开发人员快速地修改原型系统， 　　然后再次请用户试用……直到得到用户认可， 　　开发人员便可据此书写规格说明文档，反映了用户的真实需求。 因此快速原型模型是不带反馈环的，这正是这种过程模型的主要优点： 软件产品的开发基本上是线性顺序进行的。 1.4.3 增量模型 ​ 增量模型也称为渐增模型，如图1.5所示。 ​ 使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。 增量模型的优点： 能在较短时间内向用户提交可完成部分工作的产品； 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。 使用增量模型的困难是： 在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。 必须把软件的体系结构设计得便于按这种方式进行扩充，即加入新构件的过程必须简单、方便，也就是说，软件体系结构必须是开放的。 从长远观点看，具有开放结构的软件拥有真正的优势，这样的软件的可维护性明显好于封闭结构的软件。 ​ 如果一个增量模型的设计非常灵活而且足够开放，那么，这样的设计将允许在不破坏产品的情况下进行维护。 意味着： 使用增量模型时开发软件和扩充软件功能（完善性维护）没有本质区别，都是向现有产品中加入新构件的过程。 维护时期反馈环很小。 1.4.4 螺旋模型 ​ 软件风险是任何软件开发项目中都普遍存在的实际问题，项目越大，软件越复杂，承担该项目所冒的风险也越大。 软件风险可能在不同程度上损害软件开发过程和软件产品质量。 ​ 因此，在软件开发过程中必须及时 识别和分析风险， 并且采取适当措施， 以消除或减少风险的危害。 ​ 构建原型是一种能使某些类型的风险降至最低的方法。 在需求分析阶段：通过快速地构建一个原型，降低交付给用户的产品不能满足用户需要的风险。 在后续的阶段中也可以通过构造适当的原型来降低某些技术风险。 螺旋模型的基本思想是，使用原型及其他方法来尽量降低风险，在每个阶段之前都增加了风险分析过程的快速原型，如图1.7所示简化的螺旋模型。 Boehm于1988年提出，主要针对大型软件项目的开发。 四个象限 制定计划 风险分析 实施工程 客户评价 制定计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。 风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施规避这些风险。 实施工程：针对每一个开发阶段的任务要求执行本开发阶段的活动。 客户评估：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其开发过程进行评审，决定是否进入螺旋线的下一个回路。 1.4.5 喷泉模型 喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠和多次反复的，就象喷泉一样，水喷上去又可以落下来，既可以落在中间，又可以落到底部。 各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求。 优点： 提高开发效率 缩短开发周期 缺点：难于管理 1.4.6面向对象过程 RUP RUP（Rational Unified Process）是由Rational公司（现被IBM公司收购）开发的一种软件工程过程框架，是一个面向对象的基于web的程序开发方法论 。 RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中 。 RUP的基本结构 RUP中的软件生命周期在时间上被分解为四个顺序的阶段：初始阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）和交付阶段（Transition）。 每个阶段结束于一个主要的里程碑(Major Milestones)，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段。 初始阶段 目标是为系统建立商业案例（business case）并确定项目的边界。 商业案例包括项目的验收规范、风险评估、所需资源估计、阶段计划等。 要确定项目边界，需识别所有与系统交互的外部实体，并在较高层次上定义外部实体与系统交互的特性，主要包括识别外部角色（actor）、识别所有用例并详细描述一些重要的用例。 阶段结束里程碑：生命周期目标（Lifecycle Objective）里程碑。生命周期目标里程碑包括一些重要的文档，如：项目构想（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始商业案例等。需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等。 细化阶段 目标是分析问题领域，建立健全的体系结构基础，编制项目计划，完成项目中高风险需求部分的开发。 里程碑：生命周期体系结构（Lifecycle Architecture）里程碑。生命周期体系结构里程碑包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。 构造阶段 将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试。从某种意义上说，构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量。 里程碑：初始运行能力（Initial Operational Capability）里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。 移交阶段 移交阶段的重点是确保软件对最终用户是可用的。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整。 里程碑：产品发布(Product Release)里程碑。此时，要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段的相重合。 RUP的迭代增量开发思想 RUP是融合了喷泉模型和增量模型的一种综合生命周期模型。 RUP的9个核心工作流 6个核心过程工作流 　　商业建模（Business Modeling） 　　需求（Requirements） 　　分析和设计（Analysis & Design） 　　实现（Implementation） 　　测试（Test） 　　部署（Deployment） 3个核心支持工作流： 　　配置和变更管理（Configuration & Change Management） 　　项目管理（Project Management） 　　环境（Environment） RUP的最佳实践： 　　短时间分区式的迭代：2～6周，不鼓励时间推迟； 　　适应性开发：小步骤、快速反馈和调整； 　　在早期迭代中解决高技术风险和高业务价值的问题； 　　不断地让用户参与迭代结果的评估，并及时获取反馈信息，以逐步阐明问题并引导项目进展； 　　在早期迭代中建立内聚的核心架构。该实践是和早期处理高技术风险和高业务价值问题有关的，因为核心架构一般和高风险因素紧密相关。 　　不断地验证质量；尽早、经常和实际地测试； 　　使用用例驱动软件建模：用例是获取需求、制定计划、进行设计、测试、编写终端用户文档的驱动力量。 　　可视化软件建模：使用UML（Unified Modeling Language，统一建模语言）进行软件建模。 　　仔细地管理需求：不要草率地对待需求，而要有机地进行需求的提出、记录、等级划分、追踪。拙劣的需求管理是项目陷入麻烦的一个常见原因。 　　实行变更请求和配置管理。 敏捷模型 　　敏捷建模（Agile Modeling，AM）是由Scott W. Ambler从许多的软件开发过程实践中归纳总结出来的一些敏捷建模价值观、原则和实践等组成的，它只是一种态度，不是一个说明性过程 。 　　AM是对已有生命周期模型的补充，它本身不是一个完整的方法论，在应用传统的生命周期模型时可以借鉴AM的过程指导思想 。 　　极限编程(eXtreme Programming, XP)是敏捷过程中最富盛名的一个，其名称中“极限”二字的含义是指把好的开发实践运用到极致。目前，极限编程已经成为一个典型的开发方法，广泛应用于需求模糊且经常改变的场合。 敏捷建模的价值观 　　沟通：建模不但能够促进团队内部开发人员之间沟通，还能够促进团队和项目干系人（project stakeholder）之间的沟通。 　　简单：画一两张图表来代替几十甚至几百行的代码，通过这种方法，建模成为简化软件和软件开发过程的关键。 　　反馈：通过图表来交流建模想法，可以快速获得彼此的反馈。 　　勇气：如果一项决策证明是不合适的时候，就需要勇气做出重大的决策：放弃或重构（refactor）先前的工作，修正建模方向。 　　谦逊：最优秀的开发人员都拥有谦逊的美德，他们总能认识到自己并不是无所不知的。 敏捷建模核心原则： 　　主张简单； 　　拥抱变化； 　　软件开发的第二个目标应是可持续性 　　递增的变化 　　令项目干系人投资最大化 　　有目的地建模 　　多种模型 　　高质量的工作 　　快速反馈 　　以有效的方式，制造出满足项目干系人所需要的软件，而不是制造无关的文档、无关的用于管理的工件，甚至无关的模型 　　轻装前进 敏捷模型补充原则： 　　内容比表示更重要 　　三人行必有我师 　　了解软件建模方法 　　了解软件开发工具 　　局部调整 　　开放诚实的沟通 　　利用好直觉 敏捷建模核心实践(极限编程) 项目干系人的积极参与 正确使用工件 集体所有制 测试性思维 并行创建模型 创建简单的内容 简单地建模 公开展示模型 切换到另外的工件 小增量建模 和他人一起建模 用代码验证 使用最简单的工具 敏捷模型补充实践： 使用建模标准 逐渐应用模式（pattern） 丢弃临时模型 合同模型要正式 为外部交流建模 为帮助理解建模 重用现有的资源 不到万不得已不更新模型 极限编程的有效实践（特色） 客户作为开发团队的成员（不一定是真客户） 使用用户素材（用户故事，记录在卡片上） 短交付周期（两周-一个月） 验收测试 结对编程 测试驱动开发 集体所有 持续集成 可持续的开发速度（每周40个小时） 开放的工作空间 及时调整计划 简单的设计 重构 使用隐喻（隐喻相当于体系结构，从客户角度来描述一个项目的全局，用户故事则从局部来描述） 极限编程的开发过程 极限编程的迭代过程 极限编程的特点 综上所述，以极限编程为代表的敏捷过程，具有对变化和不确定性的更快速，更敏捷的反映特性，而且在快速的同时仍然能保持可持续的开发速度。上述这些特点使得敏捷过程能够较好的适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。 微软过程 作为世界上最大的同时也是最成功的软件公司之一，Microsoft（微软）公司拥有自己独特的软件开发过程，几十年的实践证明微软过程是非常成功和行之有效的。 主要内容 微软过程准则 微软软件生命周期 微软过程模型 微软过程准则 项目计划应该兼顾未来的不确定因素 用有效的风险管理来减少不确定因素的影响 经常生成并快速地测试软件的过渡版本，从而提高产品地稳定性和可预测性 采用快速循环，递进地开发过程 用创造性地工作来平衡产品特性和产品成本 项目进度表应该具有较高稳定性和权威性 使用小型项目组并发地完成开发工作 在项目早期把软件配置项基线化，项目后期则冻结产品 使用原型验证概念，对项目进行早期论证 把零缺陷作为追求的目标 里程碑评审会的目的是改进工作，切忌相互指责 微软软件生命周期 五个阶段及里程碑 （1）规划阶段 确定产品目标。 获取竞争对手的信息。 完成对客户和市场的调研分析。 确定新版本产品应具备的主要特征。 确定相对于前一版本而言，新版本应该解决的问题和需要增加的功能。 （2）设计阶段 根据产品目标编写系统的特性规格说明书。主要描述软件特性、系统结构、各构件间的相关性以及接口标准。 从系统高层着手开始进行系统设计，主要完成：系统设计方案，描绘系统结构图，确定系统中存在的风险因素，分析系统的可重用性。 划分出系统的子系统，给出各自系统和各个构件的规格说明。 根据产品特性规格说明书制定产品开发计划。 （3）开发阶段 完成产品中所有构件的开发工作，包括编写程序代码和书写文档。 （4）稳定阶段 对产品进行测试和调式，以确保已经正确地实现了整个解决方案，产品可以发布了。 （5）发布阶段 发布产品获解决方案，并把项目移交到运营和支持人员手中，以获得最终用户对项目的认可。 微软过程的生命周期模型 微软过程小结 综合了Rational同一过程和敏捷过程的许多优点，是对众多成功项目的开发经验的正确总结； 有某些不足之处，例如，对方法，工具和产品等方面的论述不如RUP和敏捷过程全面。 在开发软件的实践中，应该把微软过程与RUP和敏捷过程结合起来，取长补短，针对不同项目的具体情况进行制定。 "},"page/1012.html":{"url":"page/1012.html","title":"软件生命周期","keywords":"","body":"软件生命周期 "},"page/1013.html":{"url":"page/1013.html","title":"问题定义","keywords":"","body":"问题定义 "},"page/1014.html":{"url":"page/1014.html","title":"可行性研究","keywords":"","body":"可行性研究 第2章 可行性研究 • 目的：用最小的代价在尽可能短的时间内确定问题是否能够解决。 • 任务：确定问题是否值得去解决。 • 首先需要进一步分析和澄清问题定义。 ​ 分析问题定义阶段初步确定的规模和目标，正确的加以肯定，有错误及时改正，对目标系统有任何约束和限制，必须把它们清楚地列举出来。 问题定义的内容 •问题的背景 •开发系统的现状 •开发的理由和条件 •开发系统的问题要求、总体要求 •问题的性质、类型范围 •要实现的目标 •功能规模 •实现目标的方案 •开发的条件、环境要求 问题定义举例 ​ 项目：教材销售系统 • 背景：人工销售效率低，容易出错 • 项目目标：建立一个高效率的、无差错的微机教材销售系统 • 项目范围：硬件利用现有微机，软件开发费用不超过5000元 • 初步设想：增加缺书统计与采购功能 • 可行性研究：建议进行一周，费用不超过500元 学生选课注册系统的《目标和范围说明书》 项目：学生注册选课系统。 • 问题：在学分制试行过程中，学生选课进行人工注册效率低，容易冲突，任课教师难以获得及时有效的课程选修学生名单。 • 项目目标：建立一个基于教学管理计算机网络的学生学期选课注册系统。 • 项目范围：硬件主要利用现有计算机教学管理网络，增配少量专用设备，软件开发费用预期2800元。 • 初步设想：为学生提供填写选课卡片和计算机网络终端查询对话两种选课方式，教学管理科能够对选课冲突学生进行随即查询，确定调整。系统主要输出课程注册数据库、学生课程表、课程成绩记载单。 • 可行性研究：由分析员和教学管理科进行，主要对系统实施方案和学校学生选课管理规程进行研究。建议进行大约10天，费用不超过200元。 2.1 可行性研究的任务 确定问题是否值得去解决的下一步。 •导出系统的逻辑模型。 探索若干种可供选择的主要解法(即系统实现方案)。从下述三方面研究每种解法的可行性： (1) 技术可行性，使用现有的技术能实现这个系统吗? (2) 经济可行性，这个系统的经济效益能超过它的开发成本吗? (3) 操作可行性，系统的操作方式在这个用户组织内行得通吗? ​ 可行性研究最根本的任务是对以后的行动方针提出建议。 ​ 如果问题没有可行的解，分析员应该建议停止这项开发工程。 ​ 如果问题值得解，分析员应该推荐一个较好的解决方案，并且为工程制定一个初步的计划。 ​ 可行性研究需要的时间长短取决于工程的规模。一般说来，可行性研究的成本只是预期的工程总成本的5%～10%。 2.2 可行性研究过程 可行性研究过程有下述一些步骤。 \\1. 复查系统规模和目标 确保分析员正在解决的问题确实是要求他解决的问题。 \\2. 研究目前正在使用的系统 ​ 现有的系统是信息的重要来源。新的目标系统必须也能完成它的基本功能； ​ 另一方面，现有的系统必然有某些缺点，新系统必须能解决旧系统中存在的问题。 \\3. 导出新系统的高层逻辑模型 （数据流图和数据字典）。 \\4. 进一步定义问题 ​ 分析员应该和用户一起再次复查问题定义、工程规模和目标，以数据流图和数据字典作为讨论的基础。 ​ 可行性研究的前4个步骤实质上构成一个循环。 ​ 定义问题，分析这个问题，导出一个试探性的解； ​ 在此基础上再次定义问题，再一次分析这个问题，修改这个解； ​ 继续这个循环过程，直到提出的逻辑模型完全符合系统目标。 \\5. 导出和评价供选择的解法 ​ 分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的(较抽象的)物理解法供比较和选择。 为每个在技术、操作和经济等方面都可行的系统制定实现进度表。 \\6. 推荐行动方针 ​ 是否继续进行这项开发工程。 \\7. 草拟开发计划 ​ 制定工程进度表 ​ 估计对各类开发人员和各种资源的需要情况，指明什么时候使用以及使用多长时间。 ​ 估计系统生命周期每个阶段的成本。 ​ 给出下一个阶段(需求分析)的详细进度表和成本估计。 \\8. 书写文档提交审查 ​ 把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。 2.3 系统流程图 ​ 系统流程图是概括地描绘物理系统的传统工具。它的基本思想是用图形符号以黑盒子形式描绘组成系统的每个部件(程序，文档，数据库，人工过程等)。 ​ 系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而不是程序流程图。 2.3.1 符号 ​ 当以概括的方式抽象地描绘一个实际系统时，仅仅使用图2.1中列出的基本符号就足够了。 ​ 当需要更具体地描绘一个物理系统时还需要使用图2.2（见书29页）中列出的系统符号。 ​ 利用这些符号可以把一个广义的输入输出操作具体化为读写存储在特殊设备上的文件（或数据库），把抽象处理具体化为特定的程序或手工操作等。 图2.1 基本符号 2.3.2 例子 ​ 举例说明系统流程图的用法。 ​ 某装配厂有一座存放零件的仓库，仓库中现有的各种零件的数量以及每种零件的库存量临界值等数据记录在库存清单主文件中。 ​ 当仓库中零件数量有变化时，应该及时修改库存清单主文件， ​ 如果哪种零件的库存量少于它的库存量临界值，则应该报告给采购部门以便定货，规定每天向采购部门送一次定货报告。 ​ 该装配厂使用一台小型计算机处理更新库存清单主文件和产生定货报告的任务。零件库存量的每一次变化称为一个事务，由放在仓库中的CRT终端输入到计算机中；系统中的库存清单程序对事务进行处理，更新存储在磁盘上的库存清单主文件，并且把必要的定货信息写在磁带上。最后，每天由报告生成程序读一次磁带，并且打印出定货报告。图2.3的系统流程图描绘了上述系统的概貌。 ​ 图中每个符号用黑盒子形式定义了组成系统的一个部件，然而并没有指明每个部件的具体工作过程；图中的箭头确定了信息通过系统的逻辑路径。 系统流程图的习惯画法是使信息在图中从顶向下或从左向右流动。 图2.3 库存清单系统的系统流程图 2.3.3 分层 ​ 面对复杂的系统时，一个比较好的方法是分层次地描绘这个系统。 ​ 首先用一张高层次的系统流程图描绘系统总体概貌，表明系统的关键功能。 ​ 然后分别把每个关键功能扩展到适当的详细程度，画在单独的一页纸上。 ​ 这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。 2.4 数据流图 ​ 数据流图(DFD)是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。在数据流图中没有任何具体的物理部件，它只是描绘数据在软件中流动和被处理的逻辑过程。 ​ 数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，因此是分析员与用户之间极好的通信工具。 ​ 此外，设计数据流图时只需考虑系统必须完成的基本逻辑功能，完全不需要考虑怎样具体地实现这些功能，所以它也是今后进行软件设计的很好的出发点。 2.4.1 符号 ​ 如图2.4(a)（见书31页）所示，数据流图有四种基本符号：正方形(或立方体)表示数据的源点或终点；圆角矩形(或圆形)代表变换数据的处理；开口矩形(或两条平行横线)代表数据存储；箭头表示数据流，即特定数据的流动方向。 ​ 注意，数据流与程序流程图(参看本书第5章)中用箭头表示的控制流有本质不同，千万不要混淆。 ​ 在数据流图中应该描绘所有可能的数据流向，而不应该描绘出现某个数据流的条件（无法表示分支条件或循环）。 ​ 处理并不一定是一个程序。一个处理框可以代表一系列程序、单个程序或者程序的一个模块；它甚至可以代表用穿孔机穿孔或目视检查数据正确性等人工处理过程。 ​ 一个数据存储也并不等同于一个文件，它可以表示一个文件、文件的一部分、数据库的元素或记录的一部分等；数据可以存储在磁盘、磁带、磁鼓、主存、微缩胶片、穿孔卡片及其他任何介质上(包括人脑)。 ​ 数据存储和数据流都是数据，仅仅所处的状态不同。数据存储是处于静止状态的数据，数据流是处于运动中的数据。 ​ 通常在数据流图中忽略出错处理，也不包括诸如打开或关闭文件之类的内务处理。 ​ 数据流图的基本要点是描绘“做什么”而不考虑“怎样做”。 ​ 有时数据的源点和终点相同，如果只用一个符号代表数据的源点和终点，则至少将有两个箭头和这个符号相连(一个进一个出)，可能其中一条箭头线相当长，这将降低数据流图的清晰度。另一种表示方法是再重复画一个同样的符号(正方形或立方体)表示数据的终点。 ​ 有时数据存储也需要重复，以增加数据流图的清晰程度。为了避免可能引起的误解，如果代表同一个事物的同样符号在图中出现在n个地方，则在这个符号的一个角上画（n-1）条短斜线做标记。 ​ 除了上述4种基本符号之外，有时也使用几种附加符号。图2.4(b)给出了这些附加符号的含义。 2.4.2 例子 ​ 假设一家工厂的采购部每天需要一张定货报表，报表按零件编号排序，表中列出所有需要再次定货的零件。 ​ 对于需要再次定货的零件应该列出下述数据： ​ 零件编号，零件名称，定货数量，目前价格，主要供应者，次要供应者。 ​ 零件入库或出库称为事务，通过放在仓库中的CRT终端把事务报告给定货系统。当某种零件的库存数量少于库存量临界值时就应该再次定货。 数据流图有4种成分： ​ 源点或终点，处理，数据存储和数据流。 ​ 因此，第一步可以从问题描述中提取数据流图的4种成分： • 首先考虑数据的源点和终点 ​ 从上面对系统的描述可以知道“采购部每天需要一张定货报表”，“通过放在仓库中的CRT终端把事务报告给定货系统”，所以采购员是数据终点，而仓库管理员是数据源点。 •处理 ​ 再一次阅读问题描述，“采购部需要报表”，显然他们还没有这种报表，因此必须有一个用于产生报表的处理。 ​ 事务的后果是改变零件库存量，然而任何改变数据的操作都是处理，因此对事务进行的加工是另一个处理。 ​ 注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。 • 数据流： ​ 系统把定货报表送给采购部，因此定货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。 • 数据存储： ​ 产生报表和处理事务这两个处理在时间上明显不匹配—— ​ 每当有一个事务发生时立即处理它， ​ 然而每天只产生一次定货报表。 ​ 因此，用来产生定货报表的数据必须存放一段时间，也就是应该有一个数据存储。 ​ 注意，并不是所有数据存储和数据流都能直接从问题描述中提取出来。 ​ 数据流图是系统的逻辑模型，然而任何计算机系统实质上都是信息处理系统，也就是说计算机系统本质上都是把输入数据变换成输出数据。 ​ 因此，任何系统的基本模型都由若干个数据源点/终点以及一个处理组成，这个处理就代表了系统对数据加工变换的基本功能。 ​ 对于上述的定货系统可以画出图2.5这样的基本系统模型。 图2.5 定货系统的基本系统模型 ​ 从基本系统模型这样非常高的层次开始画数据流图是一个好办法。在这个高层次的数据流图上是否列出了所有给定的数据源点/终点是一目了然的，因此它是很有价值的通信工具。 ​ 然而，图2.5毕竟太抽象了，从这张图上对定货系统所能了解到的信息非常有限。 ​ 下一步应该把基本系统模型细化，描绘系统的主要功能。 ​ 从表2.1可知，“产生报表”和“处理事务”是系统必须完成的两个主要功能，它们将代替图2.5中的“定货系统”(图2.6)。 ​ 此外，细化后的数据流图中还增加了两个数据存储： ​ 处理事务需要“库存清单”数据； ​ 产生报表和处理事务在不同时间，因此需要存储“定货信息”。 ​ 除了表2.1中列出的两个数据流之外还有另外两个数据流，它们与数据存储相同。 ​ 这是因为从一个数据存储中取出来的或放进去的数据通常和原来存储的数据相同，也就是说，数据存储和数据流只不过是同样数据的两种不同形式。 ​ 在图2.6中给处理和数据存储都加了编号，这样做的目的是便于引用和追踪。 图2.6 定货系统的功能级数据流图 ​ 接下来应该对功能级数据流图中描绘的系统主要功能进一步细化。 ​ 考虑通过系统的逻辑数据流：当发生一个事务时必须首先接收它；随后按照事务的内容修改库存清单；最后如果更新后的库存量少于库存量临界值时，则应该再次定货，也就是需要处理定货信息。 ​ 因此，把“处理事务”这个功能分解为下述3个步骤，这在逻辑上是合理的：“接收事务”、“更新库存清单”和“处理定货”(图2.7)。 ​ 当对数据流图分层细化时必须保持信息连续性，也就是说，当把一个处理分解为一系列处理时，分解前和分解后的输入输出数据流必须相同。 图2.7 把处理事务的功能进一步分解后的数据流图 2.4.3 命名 ​ 数据流图中每个成分的命名是否恰当，直接影响数据流图的可理解性。因此，给这些成分起名字时应该仔细推敲。下面讲述在命名时应注意的问题： \\1. 为数据流(或数据存储)命名 (1) 名字应代表整个数据流(或数据存储)的内容，而不是仅仅反映它的某些成分。 (2) 不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。 (3) 如果在为某个数据流(或数据存储)起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。 \\2. 为处理命名 (1) 通常先为数据流命名，然后再为与之相关联的处理命名。这样命名比较容易，而且体现了人类习惯的“由表及里”的思考过程。 (2) 名字应该反映整个处理的功能，而不是它的一部分功能。 (3) 名字最好由一个具体的及物动词加上一个具体的宾语组成。应该尽量避免使用“加工”、“处理”等空洞笼统的动词作名字。 (4) 通常名字中仅包括一个动词，如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。 (5) 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。 数据源点/终点并不需要在开发目标系统的过程中设计和实现，它并不属于数据流图的核心内容，只不过是目标系统的外围环境部分(可能是人员、计算机外部设备或传感器装置)。通常，为数据源点/终点命名时采用它们在问题域中习惯使用的名字(如“采购员”、“仓库管理员”等)。 2.4.4 用途 ​ 画数据流图的基本目的是利用它作为交流信息的工具。分析员把他对现有系统的认识或对目标系统的设想用数据流图描绘出来，供有关人员审查确认。由于在数据流图中通常仅仅使用4种基本符号，而且不包含任何有关物理实现的细节，因此，绝大多数用户都可以理解和评价它。 ​ 数据流图应该分层，并且在把功能级数据流图细化后得到的处理超过9个时，应该采用画分图的办法，也就是把每个主要功能都细化为一张数据流分图，而原有的功能级数据流图用来描绘系统的整体逻辑概貌。 ​ 数据流图的另一个主要用途是作为分析和设计的工具。 ​ 分析员在研究现有的系统时常用系统流程图表达他对这个系统的认识，这种描绘方法形象具体，比较容易验证它的正确性； ​ 但是，开发工程的目标往往不是完全复制现有的系统，而是创造一个能够完成相同的或类似的功能的新系统。 ​ 用系统流程图描绘一个系统时，系统的功能和实现每个功能的具体方案是混在一起的。 ​ 因此，分析员希望以另一种方式进一步总结现有的系统，这种方式应该着重描绘系统所完成的功能而不是系统的物理实现方案。数据流图是实现这个目标的极好手段。 ​ 当用数据流图辅助物理系统的设计时，以图中不同处理的定时要求为指南，能够在数据流图上画出许多组自动化边界，每组自动化边界可能意味着一个不同的物理系统，因此可以根据系统的逻辑模型考虑系统的物理实现。 ​ 例如，考虑图2.7，事务随时可能发生，因此处理1.1(“接收事务”)必须是联机的；采购员每天需要一次定货报表，因此处理2(“产生报表”)应该以批量方式进行。 ​ 问题描述并没有对其他处理施加限制，例如，可以联机地接收事务并放入队列中，然而更新库存清单、处理定货和产生报表以批量方式进行(图2.8)。当然，这种方案需要增加一个数据存储以存放事务数据。 图2.8 这种划分自动化边界的方法暗示以批量方式更新库存清单 ​ 改变自动化边界，把处理1.1，1.2和1.3放在同一个边界内(图2.9)，这个系统将联机地接收事务、更新库存清单和处理定货及输出定货信息；然而处理2将以批量方式产生定货报表。 ​ 还能设想出建立自动化边界的其他方案吗? ​ 如果把处理1.1和处理1.2放在一个自动化边界内，把处理1.3和处理2放在另一个边界内，意味着什么样的物理系统呢? ​ 数据流图对更详细的设计步骤也有帮助，本书第5章将讲述从数据流图出发映射出软件结构的方法——面向数据流的设计方法。 图2.9 另一种划分自动化边界的方法建议以联机方式更新库存清单 2.5 数据字典 ​ 数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。 ​ 任何字典最主要的用途都是供人查阅对不了解的条目的解释，数据字典的作用也正是在软件分析和设计的过程中给人提供关于数据的描述信息。 ​ 数据流图和数据字典共同构成系统的逻辑模型，没有数据字典数据流图就不严格，然而没有数据流图数据字典也难于发挥作用。只有数据流图和对数据流图中每个元素的精确定义放在一起，才能共同构成系统的规格说明。 2.5.1 数据字典的内容 ​ 一般说来，数据字典应该由对下列4类元素的定义组成： (1) 数据流 (2) 数据流分量(即数据元素) (3) 数据存储 (4) 处理 ​ 但是，对数据处理的定义用其他工具(如IPO图或PDL)描述更方便，因此本书中数据字典将主要由对数据的定义组成，这样做可以使数据字典的内容更单纯，形式更统一。 ​ 除了数据定义之外，数据字典中还应该包含关于数据的一些其他信息。 ​ 典型的情况是，在数据字典中记录数据元素的下列信息： 一般信息(名字，别名，描述等等)，定义(数据类型，长度，结构等等)，使用特点(值的范围，使用频率，使用方式——输入、输出、本地，条件值等等)，控制信息(来源，用户，使用它的程序，改变权，使用权等等)和分组信息(父结构，从属结构，物理位置——记录、文件和数据库等等)。 ​ 数据元素的别名就是该元素的其他等价的名字，出现别名主要有下述3个原因： (1) 对于同样的数据，不同的用户使用了不同的名字； (2) 一个分析员在不同时期对同一个数据使用了不同的名字； (3) 两个分析员分别分析同一个数据流时，使用了不同的名字。 虽然应该尽量减少出现别名，但是不可能完全消除别名。 2.5.2 定义数据的方法 ​ 定义绝大多数复杂事物的方法，都是用被定义的事物的成分的某种组合表示这个事物，这些组成成分又由更低层的成分的组合来定义。从这个意义上说，定义就是自顶向下的分解，所以数据字典中的定义就是对数据自顶向下的分解。那么，应该把数据分解到什么程度呢?一般说来，当分解到不需要进一步定义，每个和工程有关的人也都清楚其含义的元素时，这种分解过程就完成了。 ​ 由数据元素组成数据的方式只有下述三种基本类型： (1) 顺序 即以确定次序连接两个或多个分量； (2) 选择 即从两个或多个可能的元素中选取一个； (3) 重复 即把指定的分量重复零次或多次。 ​ 因此，可以使用上述3种关系算符定义数据字典中的任何条目。为了说明重复次数，重复算符通常和重复次数的上下限同时使用(当上下限相同时表示重复次数固定)。当重复的上下限分别为1和0时，可以用重复算符表示某个分量是可选的。但是，“可选”是由数据元素组成数据时一种常见的方式，把它单独列为一种算符可以使数据字典更清晰一些。因此，增加了下述的第4种关系算符： (4) 可选 即一个分量是可有可无的(重复零次或一次)。 ​ 虽然可以使用自然语言描述由数据元素组成数据的关系，但是为了更加清晰简洁，建议采用下列符号： =意思是等价于(或定义为)； +意思是和(即，连接两个分量)； ［ ］意思是或(即，从方括弧内列出的若干个分量中选择一个)，通常用“|”号隔开供选择的分量； { }意思是重复(即，重复花括弧内的分量)； ( )意思是可选(即，圆括弧里的分量可有可无)。 ​ 常常使用上限和下限进一步注释表示重复的花括弧。一种注释方法是在开括弧的左边用上角标和下角标分别表明重复的上限和下限；另一种注释方法是在开括弧左侧标明重复的下限，在闭括弧的右侧标明重复的上限。 ​ 下面举例说明上述定义数据的符号的使用方法：某程序设计语言规定，用户说明的标识符是长度不超过8个字符的字符串，其中第一个字符必须是字母字符，随后的字符既可以是字母字符也可以是数字字符。使用上面讲过的符号，我们可以像下面那样定义标识符： 标识符=字母字符+字母数字串 字母数字串=0｛字母或数字｝7 字母或数字=［字母字符｜数字字符］ ​ 由于和项目有关的人都知道字母字符和数字字符的含义，因此，关于标识符的定义分解到这种程度就可以结束了。 2.5.3 数据字典的用途 ​ 数据字典最重要的用途是作为分析阶段的工具。 ​ 在数据字典中建立的一组严密一致的定义很有助于改进分析员和用户之间的通信，因此将消除许多可能的误解。 ​ 对数据的这一系列严密一致的定义也有助于改进在不同的开发人员或不同的开发小组之间的通信。 ​ 如果要求所有开发人员都根据公共的数据字典描述数据和设计模块，则能避免许多麻烦的接口问题。 ​ 数据字典中包含的每个数据元素的控制信息是很有价值的。 ​ 因为列出了使用一个给定的数据元素的所有程序(或模块)，所以很容易估计改变一个数据将产生的影响，并且能对所有受影响的程序或模块作出相应的改变。 ​ 最后，数据字典是开发数据库的第一步，而且是很有价值的一步。 2.5.4 数据字典的实现 ​ 目前，数据字典几乎总是作为CASE“结构化分析与设计工具”的一部分实现的。 ​ 在开发大型软件系统的过程中，数据字典的规模和复杂程度迅速增加，人工维护数据字典几乎是不可能的。 ​ 如果在开发小型软件系统时暂时没有数据字典处理程序，建议采用卡片形式书写数据字典，每张卡片上保存描述一个数据的信息。这样做更新和修改起来比较方便，而且能单独处理描述每个数据的信息。每张卡片上主要应该包含下述这样一些信息： 名字、别名、描述、定义、位置。 2.6 成本/效益分析 ​ 开发一个软件系统是一种投资，期望将来获得更大的经济效益。 ​ 经济效益通常表现为减少运行费用或(和)增加收入。但是，投资开发新系统往往要冒一定风险，系统的开发成本可能比预计的高，效益可能比预期的低。 ​ 效益分析的目的正是要从经济角度分析开发一个特定的新系统是否划算，从而帮助客户组织的负责人正确地作出是否投资于这项开发工程的决定。 ​ 为了对比成本和效益，首先需要估计它们的数量。 2.6.1 成本估计 ​ 软件开发成本主要表现为人力消耗(乘以平均工资则得到开发费用)。成本估计不是精确的科学，因此应该使用几种不同的估计技术以便相互校验。下面简单介绍3种估算技术。 \\1. 代码行技术 ​ 代码行技术是比较简单的定量估算方法，它把开发每个软件功能的成本和实现这个功能需要用的源代码行数联系起来。通常根据经验和历史数据估计实现一个功能需要的源程序行数。当有以往开发类似工程的历史数据可供参考时，这个方法是非常有效的。 ​ 一旦估计出源代码行数以后，用每行代码的平均成本乘以行数就可以确定软件的成本。每行代码的平均成本主要取决于软件的复杂程度和工资水平。 \\2. 任务分解技术 ​ 这种方法首先把软件开发工程分解为若干个相对独立的任务。再分别估计每个单独的开发任务的成本，最后累加起来得出软件开发工程的总成本。 ​ 估计每个任务的成本时，通常先估计完成该项任务需要用的人力(以人月为单位)，再乘以每人每月的平均工资而得出每个任务的成本。 ​ 最常用的办法是按开发阶段划分任务。如果软件系统很复杂，由若干个子系统组成，则可以把每个子系统再按开发阶段进一步划分成更小的任务。 ​ 典型环境下各个开发阶段需要使用的人力的百分比大致如表2.2（见书40页）所示。当然，应该针对每个开发工程的具体特点，并且参照以往的经验尽可能准确地估计每个阶段实际需要使用的人力。 \\3. 自动估计成本技术 ​ 采用自动估计成本的软件工具可以减轻人的劳动，并且使得估计的结果更客观。但是，采用这种技术必须有长期搜集的大量历史数据为基础，并且需要有良好的数据库系统支持。 2.6.2 成本/效益分析的方法 ​ 成本/效益分析的第一步是估计开发成本、运行费用和新系统将带来的经济效益。 • 估计开发成本以介绍。 • 运行费用取决于系统的操作费用(操作员人数，工作时间，消耗的物资等等)和维护费用。 • 系统的经济效益等于因使用新系统而增加的收入加上使用新系统可以节省的运行费用。 ​ 因为运行费用和经济效益两者在软件的整个生命周期内都存在，总的效益和生命周期的长度有关，所以应该合理地估计软件的寿命。 ​ 虽然许多系统在开发时预期生命周期长达10年以上，但是时间越长系统被废弃的可能性也越大，为了保险起见，以后在进行成本/效益分析时一律假设生命周期为5年。 ​ 应该比较新系统的开发成本和经济效益，以便从经济角度判断这个系统是否值得投资，但是，投资是现在进行的，效益是将来获得的，不能简单地比较成本和效益，应该考虑货币的时间价值。 \\1. 货币的时间价值 ​ 通常用利率的形式表示货币的时间价值。 ​ 假设年利率为i，如果现在存入P元，则n年后可以得到的钱数为：F=P(1+i)n ​ 这也就是P元钱在n年后的价值。 ​ 反之，如果n年后能收入F元钱，那么这些钱的现在价值是 ​ P=F/(1+i)n ​ 例如，修改一个已有的库存清单系统，使它能在每天送给采购员一份定货报表。 ​ 修改已有的库存清单程序并且编写产生报表的程序，估计共需5000元； ​ 系统修改后能及时定货将消除零件短缺问题，估计因此每年可以节省2500元，5年共可节省12500元。 ​ 但是，不能简单地把5000元和12500元相比较，因为前者是现在投资的钱，后者是若干年以后节省的钱。 ​ 假定年利率为12%，利用上面计算货币现在价值的公式可以算出修改库存清单系统后每年预计节省的钱的现在价值，如表2.3（见书41页）所示。 \\2. 投资回收期 ​ 通常用投资回收期衡量一项开发工程的价值。 ​ 所谓投资回收期就是使累计的经济效益等于最初投资所需要的时间。 ​ 显然，投资回收期越短就能越快获得利润，因此这项工程也就越值得投资。 ​ 举例：参见P42 ​ 投资回收期仅仅是一项经济指标，为了衡量一项开发工程的价值，还应该考虑其他经济指标。 \\3. 纯收入 ​ 衡量工程价值的另一项经济指标是工程的纯收入，也就是在整个生命周期之内系统的累计经济效益(折合成现在值)与投资之差。 ​ 这相当于比较投资开发一个软件系统和把钱存在银行中(或贷给其他企业)这两种方案的优劣。 ​ 如果纯收入为零，则工程的预期效益和在银行存款一样，但是开发一个系统要冒风险，因此从经济观点看这项工程可能是不值得投资的。 ​ 如果纯收入小于零，那么这项工程显然不值得投资。 \\4. 投资回收率 ​ 把资金存入银行或贷给其他企业能够获得利息，通常用年利率衡量利息多少。 ​ 类似地也可以计算投资回收率，用它衡量投资效益的大小，并且可以把它和年利率相比较。 ​ 在衡量工程的经济效益时，它是最重要的参考数据。 ​ 已知现在的投资额，并且已经估计出将来每年可以获得的经济效益，那么，给定软件的使用寿命之后，怎样计算投资回收率呢? ​ 设想把数量等于投资额的资金存入银行，每年年底从银行取回的钱等于系统每年预期可以获得的效益，在时间等于系统寿命时，正好把在银行中的存款全部取光，那么，年利率等于多少呢? ​ 这个假想的年利率就等于投资回收率。 2.7 小结 ​ 可行性研究进一步探讨问题定义阶段所确定的问题是否有可行的解。 ​ 在对问题正确定义的基础上，通过分析问题，导出试探性的解，然后复查并修正问题定义，再次分析问题，改进提出的解法……。 ​ 经过定义问题、分析问题、提出解法的反复过程，最终提出一个符合系统目标的高层次的逻辑模型。 ​ 然后根据系统的这个逻辑模型设想各种可能的物理系统，并且从技术、经济和操作等各方面分析这些物理系统的可行性。 ​ 最后，系统分析员提出一个推荐的行动方针，提交用户和客户组织负责人审查批准。 ​ 在表达分析员对现有系统的认识和描绘他对未来的物理系统的设想时，系统流程图是一个很好的工具。系统流程图实质上是物理数据流图，它描绘组成系统的主要物理元素以及信息在这些元素间流动和处理的情况。 ​ 数据流图的基本符号只有4种，它是描绘系统逻辑模型的极好工具。通常数据字典和数据流图共同构成系统的逻辑模型。没有数据字典精确定义数据流图中每个元素，数据流图就不够严密；然而没有数据流图，数据字典也很难发挥作用。 ​ 成本/效益分析是可行性研究的一项重要内容，是客户组织负责人从经济角度判断是否继续投资于这项工程的主要依据。 "},"page/1015.html":{"url":"page/1015.html","title":"需求分析","keywords":"","body":"需求分析 第3章 需求分析 • 基本任务是准确地回答：“系统必须做什么?” 。 ​ 对目标系统提出完整、准确、清晰、具体的要求。 • 系统分析员应该写出软件需求规格说明书。 需求分析应遵守下述准则： (1) 必须理解并描述问题的信息域，建立数据模型。 (2) 必须定义软件应完成的功能，建立功能模型。 (3) 必须描述作为外部事件结果的软件行为，建立行为模型。 (4) 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。 3.1 需求分析的任务 3.1.1 确定对系统的综合要求 \\1. 功能需求 ​ 指定系统必须提供的服务，划分出系统必须完成的所有功能。 \\2. 性能需求 ​ 指定系统必须满足的定时约束或容量约束，通常包括速度(响应时间)、信息量速率、主存容量、磁盘容量、安全性等方面的需求。 \\3. 可靠性和可用性需求 \\4. 出错处理需求 ​ 当应用系统发现它自己犯下一个错误时所采取的行动。但是，仅限于对系统的关键部分有选择地提出这类出错处理需求。 \\5. 接口需求 ​ 描述应用系统与它的环境通信的格式。 ​ 常见的接口需求有：用户接口需求；硬件接口需求；软件接口需求；通信接口需求。 \\6. 约束 ​ 描述在设计或实现应用系统时应遵守的限制条件。 ​ 常见的约束有：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台。 \\7. 逆向需求 ​ 说明软件系统不应该做什么。 ​ 用于澄清真实需求，消除可能发生的误解的那些逆向需求。 \\8. 将来可能提出的要求 ​ 对系统将来可能的扩充和修改预做准备。 3.1.2 分析系统的数据要求 这是软件需求分析的一个重要任务。 ​ 通常采用建立数据模型的方法(ER图)。 表示方法： ​ 数据结构（表示数据元素之间的逻辑关系） ​ 数据字典（不够形象直观） ​ 层次方框图和Warnier图（3.7节介绍） 存储方式： ​ 数据库或文件。 3.1.3 导出系统的逻辑模型 • 综合上述两个步骤的结果导出系统的逻辑模型 • 用以下工具描述 ​ 数据流图 ​ 实体联系图 ​ 状态转换图 ​ 数据字典 ​ 主要的处理算法 3.1.4 修正系统开发计划 •修正可行性分析中制定的开发计划 •估计比较准确的系统成本和进度 3.2 与用户沟通获取需求的方法 3.2.1 访谈 • 正式 • 非正式 • 调查表 • 情景分析技术 3.2.2 面向数据流自顶向下求精 ​ 结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法。 • 可行性研究得出的是目标系统的高层数据流图 • 需求分析的目标之一就是把数据流和数据存储定义到元素级。 • 从数据流图的输出端着手分析，输出数据决定了系统必须具有的最基本的组成元素。 　　输出数据组成元素通过调查访问不难搞清。 ​ 每个输出数据元素又是从哪里来的呢? ​ 或者是从外面输入到系统中来，或者是通过计算由系统中产生出来的。 • 从输出端往输入端回溯，可确定每个数据元素的来源，及有关的算法。 ​ 但是，高层数据流图中许多细节没有包括，因此回溯时常常遇到下述问题： ​ 某个数据元素需要用到数据流图中目前还没有的数据元素， ​ 或者得出这个数据元素需要用的算法尚不完全清楚。 • 数据元素归入数据字典 • 算法记录在IPO图中 • 增补数据流图 • 请用户复查 ​ 复查过程验证了已知的元素，补充了未知的元素，填补了文档中的空白。 • 追踪更详细的数据流，把数据流图扩展到更低的层次。通过功能分解完成数据流图的细化。 ​ 在分析追踪时可能产生新的问题，这些问题的答案可能又在数据字典中增加一些新条目，或产生新的或精化的算法描述。 ​ 最终得到对系统数据和功能要求的满意了解。 下页图3.1粗略地概括了上述分析过程。 图3.1 面向数据流自顶向下求精过程 3.2.3 简易的应用规格说明技术 ​ 为了解决上述问题，人们研究出一种面向团队的需求收集法，称为简易的应用规格说明技术。 ​ 这种方法提倡用户与开发者密切合作，商讨不同方案并指定基本需求。 •初步访谈，确定问题和解决方案 •开发者和用户分别写“产品需求” •开会前，将“产品需求”分发 •每个人审查“产品需求”，列出系统对象 •开会，合并对象（消去冗余），得到意见一致的列表 •分小组讨论，制定小型规格说明 •综合讨论，起草软件规格说明书 3.2.4 快速建立软件原型 •快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序。其特性： ​ 快速 ​ 容易修改 •为了快速地构建和修改原型，通常使用下述3种方法和工具： ​ 第四代技术（使得软件工程师能够快速地生成可执行的代码，是较理想的快速原型工具） ​ 可重用的软件构件（使用一组已有的软件构件来装配原型） ​ 形式化规格说明和原型环境（调用自动工具把基于形式语言的规格说明翻译成可执行的程序代码） 3.3 分析建模与规格说明 3.3.1 分析建模 ​ 为了更好地理解复杂事物，人们常常采用建立事物模型的方法。 ​ 所谓模型，是为了理解事物而对事物做出的一种抽象，是一种无歧义的书面描述。 ​ 模型由一组图形符号和组织这些符号的规则组成。 ​ 根据结构化分析准则，需求分析过程应该建立3种模型，它们分别是数据模型、功能模型和行为模型。 数据模型 实体－联系图，描绘数据对象及数据对象之间的关系，用于建立数据模型。 功能模型 数据流图，描绘当数据在软件系统中移动时被变换的逻辑过程，指明系统具有变化数据的功能，是建立功能模型的基础。 行为模型 3.6节状态转换图（状态图），指明作为外部事件结果的系统行为。描绘了系统的各种行为模式(称为“状态”)和在不同状态间转换的方式。是行为建模的基础。 3.3.2 软件需求规格说明 ​ 是需求分析阶段得出的最主要的文档。 • 用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。 • 自然语言的规格说明具有容易书写、容易理解的优点，为大多数人所欢迎和采用。 3.4 实体——联系图 数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系。 3.4.1 数据对象 数据对象是对软件必须理解的复合信息的抽象。 数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。总之，可以由一组属性来定义的实体都可以被认为是数据对象。 3.4.2 属性 属性定义了数据对象的性质。 必须把一个或多个属性定义为“标识符”，也就是说，当人们希望找到数据对象的一个实例时，用标识符属性作为“关键字”(通常简称为“键”)。 3.4.3 联系 客观世界中的事物彼此间往往是有联系的。 数据对象彼此之间相互连接的方式称为联系，也称为关系。联系可分为以下3种类型。 一对一联系(1∶1) 一对多联系(1∶N) 多对多联系(M∶N) (1) 一对一联系(1∶1) 例如，一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的。 (2) 一对多联系(1∶N) 例如，某校教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教(见图3.2)。 (3) 多对多联系(M∶N) 例如，图3.2表示学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。 3.4.4、实体联系图的符号 通常，使用实体联系图(entityrelationship diagram)来建立数据模型。可以把实体联系图简称为ER图，相应地可把用ER图描绘的数据模型称为ER模型。 ER图中包含了实体(即数据对象)、关系和属性3种基本成分，通常用矩形框代表实体，用连接相关实体的菱形框表示关系，用椭圆形或圆角矩形表示实体(或关系)的属性，并用直线把实体(或关系)与其属性连接起来。 ER模型可以作为用户与分析员之间有效的交流工具。 3.5 数据规范化 ​ 软件系统经常使用的各种长期保存的信息，通常以一定方式组织并存储在数据库或文件中，为减少数据冗余，避免出现插入异常或删除异常，通常需要把数据结构规范化。 3.6 状态转换图 ​ 用于建立软件系统的行为模型。 ​ 通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。 ​ 此外，还指明了作为特定事件的结果系统将做哪些动作(例如，处理数据)。 ​ 因此，状态图提供了行为建模机制。 3.6.1 状态 状态： ​ 是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。 在状态图中定义的状态主要有： ​ 初态(即初始状态)、终态(即最终状态)和中间状态。 ​ 在一张状态图中只能有一个初态，而终态则可以有0至多个。 ​ 当描绘单程生命期时，需要标明 ​ 初始状态(系统启动时进入初始状态)和 ​ 最终状态(系统运行结束时到达最终状态)。 ​ 描绘循环运行过程时不必。 3.6.2 事件 ​ 事件是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。 ​ 例如，内部时钟表明某个规定的时间段已经过去，用户移动或点击鼠标等都是事件。 ​ 简而言之，事件就是引起系统做动作或(和)转换状态的控制信息。 3.6.3 符号 初态用实心圆表示， 终态用一对同心圆(内圆为实心圆)表示。 中间状态用圆角矩形表示， ​ 可以用两条水平横线把它分成上、中、下3个部分。 上面部分为状态的名称，这部分是必须有的； 中间部分为状态变量的名字和值，这部分是可选的； 下面部分是活动表，这部分也是可选的。 活动表的语法格式：事件名(参数表)/动作表达式 • “事件名”可以是任何事件的名称。 ​ 经常使用下述3种标准事件：entry，exit和do。 ​ entry指定进入该状态的动作， ​ exit指定退出该状态的动作， ​ do指定在该状态下的动作。 • 需要时可以为事件指定参数表。 • 动作表达式描述应做的具体动作。 • 两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。 状态变迁通常是由事件触发的，在状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。 事件表达式的语法如下： 事件说明［守卫条件］／动作表达式 • 事件说明的语法为：事件名(参数表)。 • 守卫条件是一个布尔表达式。 ​ 如果同时使用事件说明和守卫条件，则当且仅当事件发生且布尔表达式为真时，状态转换才发生。 ​ 如果只有守卫条件没有事件说明，则只要守卫条件为真状态转换就发生。 • 动作表达式是一个过程表达式，当状态转换开始时执行该表达式。 3.6.4 例子 图3.4（见书57页） ​ 没有人打电话时电话处于闲置状态； ​ 有人拿起听筒则进入拨号音状态，到达这个状态后，电话的行为是响起拨号音并计时； ​ 这时如果拿起听筒的人改变主意不想打了，他把听筒放下(挂断)，电话重又回到闲置状态； ​ 如果拿起听筒很长时间不拨号(超时)，则进入超时状态；……。 3.7 其他图形工具 3.7.1 层次方框图 ​ 用树形结构的一系列多层次的矩形框描绘数据的层次结构。 ​ 树形结构顶层的矩形框，代表完整的数据结构， ​ 下面的各层矩形框代表这个数据的子集， ​ 最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)。 ​ 例如，描绘一家计算机公司全部产品的数据结构可以用图3.5中的层次方框图表示。 图3.5 层次方框图的一个例子 3.7.1 层次方框图 ​ 从对顶层信息的分类开始，沿图中每条路径反复细化，直到确定了数据结构的全部细节时为止。 3.7.2 Warnier图 ​ 表示信息层次结构的另外一种图形工具。 ​ 但这种图形工具比层次方框图提供了更丰富的描绘手段。 用Warnier图可以表明信息的逻辑组织， ​ 它可以指出一类信息或一个信息元素是重复出现的， ​ 也可以表示特定信息在某一类信息中是有条件地出现的。 图3.6中的Warnier图表示 ​ 一种软件产品要么是系统软件要么是应用软件。 ​ 系统软件中有P1种操作系统，P2种编译程序，此外还有软件工具。 ​ 软件工具是系统软件的一种，它又可以进一步细分为编辑程序、测试驱动程序和设计辅助工具，并标出了每种软件工具的数量。 图3.6 Warnier图的一个例子 3.7.3 IPO图 ​ IPO图是输入、处理、输出图的简称，它是美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。 ​ IPO图使用的基本符号既少又简单，因此很容易学会使用这种图形工具。 ​ 在左边的框中列出有关的输入数据， ​ 在中间的框内列出主要的处理， ​ 在右边的框内列出产生的输出数据。 ​ 处理框中列出处理的次序暗示了执行的顺序。 ​ 在IPO图中还用粗大箭头指出数据通信的情况。 图3.7是一个主文件更新的例子，通过这个例子不难了解IPO图的用法。 图3.7 IPO图的一个例子图 ​ 建议使用一种改进的IPO图(也称为IPO表)，图中包含某些附加的信息，比原始的IPO图更有用。如图3.8所示。 ​ 在需求分析阶段可以使用IPO图简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。 当许多附加信息暂时还不具备时，在软件设计阶段可以进一步补充修正这些图，作为设计阶段的文档。 ​ 这正是在需求分析阶段用IPO图作为描述算法的工具的重要优点。 图3.8 改进的IPO图的形式 3.8 验证软件需求 3.8.1 从哪些方面验证软件需求的正确性 ​ 软件系统中15%的错误起源于错误的需求。 一般说来，应该从下述4个方面进行验证： (1) 一致性：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。 (2) 完整性：需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。 (3) 现实性：指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。 (4) 有效性：必须证明需求是正确有效的，确实能解决用户面对的问题。 3.8.2 验证软件需求的方法 \\1. 验证需求的一致性 •人工审查（正确性不能保证） •形式化描述软件需求的方法：当软件需求规格说明书是用形式化的需求陈述语言书写时，可以用软件工具验证需求的一致性。 \\2. 验证需求的现实性 • 经验 • 应该采用仿真或性能模拟技术，辅助分析软件需求规格说明书的现实性。 \\3. 验证需求的完整性和有效性 • 用户是需求的权威，但是不能很好表达自己的需求 • 根据需求开发一个软件系统，用户试用，成本翻倍 • 建立快速原型系统，使用户提出更符合实际的要求 3.8.3 用于需求分析的软件工具 ​ 为了有效地保证软件需求的正确性，特别是一致性，需要有适当的软件工具支持需求分析工作。 这类软件工具应该满足下列要求： (1) 必须有形式化的语法(或表)，使可以用计算机自动处理使用这种语法说明的内容； (2) 使用这个软件工具能够导出详细的文档； (3) 必须提供分析(测试)规格说明书的不一致性和冗余性的手段，并且应该能够产生一组报告指明对完整性分析的结果； (4) 使用这个软件工具之后，应该能够改进通信状况。 "},"page/1016.html":{"url":"page/1016.html","title":"总体设计","keywords":"","body":"总体设计 第5章 总体设计 总体设计任务 • 系统方案设计 ​ 划分出组成系统的物理元素——程序、文件、数据库、人工过程和文档等等，但是每个物理元素仍然处于黑盒子级。 • 体系结构设计 ​ 设计软件的结构，确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。 5.1 设计过程 两个主要阶段组成： 系统设计阶段：确定系统的具体实现方案； 结构设计阶段：确定软件结构。 ​ 典型的总体设计过程包括下述9个步骤： \\1. 设想供选择的方案 ​ 以数据流图为基础，寻找实现目标系统的各种不同的方案。 \\2. 选取合理的方案 ​ 至少选取低成本、中等成本和高成本的三种方案。 ​ 对每个合理的方案分析员都应该准备下列资料： (1) 系统流程图； (2) 组成系统的物理元素清单； (3) 成本/效益分析； (4) 实现这个系统的进度计划。 \\3. 推荐最佳方案 \\4. 功能分解 确定软件结构，从实现角度把复杂的功能进一步分解。 通常分为两个阶段完成： ​ 结构设计：确定程序由哪些模块组成，以及这些模块之间的关系。总体设计阶段的任务 ​ 过程设计：确定每个模块的处理过程。 ​ 详细设计阶段的任务 ​ 功能分解导致数据流图的进一步细化，同时用IPO图简要描述细化后每个处理的算法。 \\5. 设计软件结构 ​ 把模块组织成良好的层次系统，顶层模块调用它的下层模块以实现程序的完整功能，每个下层模块再调用更下层的模块，从而完成程序的一个子功能，最下层的模块完成最具体的功能。 软件结构(即由模块组成的层次系统)可以用层次图或结构图来描绘，第5.4节将介绍这些图形工具。 ​ 如果数据流图已经细化到适当的层次，可以直接从数据流图映射出软件结构，这就是第5.5节中将要讲述的面向数据流的设计方法。 \\6. 设计数据库 \\7. 制定测试计划 ​ 开发早期考虑测试问题，可提高软件的可测试性。 \\8. 书写文档 (1) 系统说明。主要内容包括： ​ 系统流程图描绘的系统构成方案，组成系统的物理元素清单，成本/效益分析； ​ 精化的数据流图，用层次图或结构图描绘的软件结构，用IPO图描述的各个模块的算法，模块间的接口关系等。 (2) 用户手册 (3) 测试计划 (4) 详细的实现计划 (5) 数据库设计结果 \\9. 审查和复审 5.2 设计原理 好的设计准则 • 模块化 • 抽象 • 逐步求精 • 信息隐藏和局部化 • 模块独立 5.2.1 模块化 模块： 是由边界元素限定的相邻程序元素（例如，数据说明，可执行的语句）的序列，而且有一个总体标识符代表它。按照模块的定义，过程、函数、子程序和宏等，都可作为模块。 模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能，满足用户的需求。 模块化的根据：把复杂的问题分解成许多容易解决的小问题，原来的问题也就容易解决了。 模块化的后果：随着模块数目增加，设计模块间接口所需要的工作量也将增加。 ​ 根据这两个因素，得出了图中的总成本曲线。每个程序都有一个最适当的模块数目M，使得系统的开发成本最小。 图5.1 模块化和软件成本 5.2.1 模块化优点 • 使软件结构清晰，容易设计也容易阅读和理解。 •提高软件的可靠性。 ​ 程序错误局限在有限的模块中，使软件容易测试和调试。 •提高了软件的可修改性。 ​ 即使有变动，往往只涉及少数几个模块， • 有助于软件开发工程的组织管理。 ​ 一个大型程序由许多程序员分工编写，分配技术熟练的程序员编写困难的模块。 5.2.2 抽象 抽象：把事务相似的方面集中和概括起来，暂时忽略它们之间的差异。 ​ 抽象就是抽出事物的本质特性而暂时不考虑它们的细节。 5.2.3 逐步求精 Miller法则：一个人在任何时候都只能把注意力集中在（7±2）个知识块上。 逐步求精是人类解决复杂问题时采用的基本方法。 逐步求精实际上是自顶向下的细化过程。 ​ 高抽象级别定义的功能，仅作概念性地描述，没有提供功能的内部工作情况。 ​ 求精要求设计者细化原始陈述，随着每个后续求精（即细化）步骤的完成，提供越来越多的细节。 ​ 抽象与求精是一对互补的概念。 ​ 抽象使得设计者能够说明过程和数据，同时却忽略低层细节。 ​ 求精则帮助设计者在设计过程中逐步揭示出低层细节。 ​ 这两个概念都有助于设计者在设计演化过程中创造出完整的设计模型。 5.2.4 信息隐藏和局部化 信息隐藏：一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。 局部化：是指把一些关系密切的软件元素物理地放得彼此靠近。 在模块中使用局部数据元素是局部化的一个例子。有助于实现信息隐藏。 5.2.5 模块独立 ​ 模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。 模块独立：具有独立功能而且和其他模块之间没有过多的相互作用的模块。 模块独立的重要性： 第一，具有独立模块的软件比较容易开发。 第二，独立模块比较容易测试和维护。 ​ 错误传播范围小，容易测试与修改，需要扩充功能时能够“插入”模块。 　模块独立程度的度量标准：内聚和耦合。 耦合：模块间互相依赖(连接)的紧密程度； 内聚：模块内部各个元素彼此结合的紧密程度。 \\1. 耦合 　影响耦合强度的因素 • 一个模块对另一个模块的引用 • 一个模块向另一个模块传递的数据量 • 一个模块施加到另一个模块的控制的数量 • 模块之间接口的复杂程度 耦合的类型 • 内容耦合　　强 • 公共耦合　　¦ • 控制耦合　　¦ • 标记耦合　　↓ • 数据耦合　　弱 　在软件设计中应该追求尽可能松散耦合。 ​ 对模块的测试或维护时，不需要对系统的其他模块有很多了解。 　此外，由于模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小。 ​ 因此，模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。 　 数据耦合 数据耦合：模块彼此间通过参数交换信息，交换的信息仅仅是数据。 　数据耦合是低耦合。系统中至少必须存在这种耦合，因为只有当某些模块的输出数据作为另一些模块的输入数据时，系统才能完成有价值的功能。 ​ 一般说来，一个系统内可以只包含数据耦合。 标记耦合 （ Stamp coupled ） • 若两个模块间传递的参数中至少有一个是数据结构，如字符串或记录，并且在模块中仅用到该数据结构中的部分元素，则称这两个模块之间存在标记耦合。 ​ 在这种情况下，被调用的模块可以使用的数据多于它确实需要的数据，将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。 控制耦合 （Control coupled） 控制耦合：一个模块向另一个模块传递控制信息，接收信息的模块的动作根据信息值进行调整。 　 ​ 控制耦合是中等程度的耦合，它增加了系统的复杂程度。在把模块适当分解之后通常可以用数据耦合代替它。 公共耦合 （ Common coupled ） •两个模块共享全局的数据区域，称他们为公共耦合。 •不要使用全局变量 公共耦合 　 耦合的复杂程度随耦合模块的个数而变化，随个数的增加显著增加。 ​ 两个模块的公共耦合有两种可能： (1) 一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。 (2) 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。 内容耦合 （ Content coupled ） •内容耦合的三种情况: •一个模块修改另一个模块的语句 (Lisp 具有此种能力) •一个模块引用或者修改另一个模块内部的数据 •一个模块不通过正常入口而跳转到另一个模块的内部 模块独立性与耦合的关系 　总之，耦合是影响软件复杂程度的一个重要因素。应该采取下述设计原则： 　尽量使用数据耦合，少用控制耦合和标记耦合，限制公共环境耦合的范围，完全不用内容耦合。 \\2. 内聚 　内聚标志一个模块内各个元素彼此结合的紧密程度。理想内聚的模块只做一件事情。 　度量一个模块内部各成分之间相互关联的强度 • 偶然内聚　　弱 • 逻辑内聚 • 时间内聚 • 过程内聚　　↓ • 通信内聚 • 顺序内聚 • 功能内聚　　强 偶然内聚 （ coincidental cohesion ） ​ 如果一个模块的各成分之间毫无关系，则称为偶然内聚。 逻辑内聚 （ logically cohesive ） 几个逻辑上相关的功能被放在同一模块中。 时间内聚 （ Temporal cohesion ） 如果一个模块完成的功能只是因为时间因素关联在一起。 时间内聚 （ Temporal cohesion ） •Consider a module called \"On_Really_Bad_Failure\" that is invoked when a Really_Bad_Failure happens. The module performs several tasks that are not functionally similar or logically related, but all tasks need to happen at the moment when the failure occurs. •The module might cancel all outstanding requests for services cut power to all assembly line machines notify the operator console of the failure make an entry in a database of failure records 过程内聚 （ procedurally cohesive ） 如果一个模块内部的各个处理成分必须以特定的次序执行，则称为过程内聚。 通信内聚 （ communicationally cohesive ） 如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。 顺序内聚 （ sequentially cohesive ） 如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。 功能内聚 （ functionally cohesive ） 模块的所有成分对于完成单一的功能都是基本的。 设计时尽量使用高内聚，低耦合模块。 • 高内聚：尽量使用内聚度高的模块；中内聚也可；低内聚很坏，不要采用。 低内聚：偶然内聚，逻辑内聚，时间内聚 中内聚：过程内聚，通信内聚 高内聚：顺序内聚，功能内聚； • 低耦合：尽量使用数据耦合，少用控制耦合和标记耦合，限制公共耦合的范围，完全不用内容耦合。 5.3 启发式规则 改进软件设计，提高软件质量的途径。 •改进软件结构提高模块独立性 •模块规模应该适中 •深度、宽度、扇出和扇入应适中 •模块的作用域应该在控制域之内 •力争降低模块接口的复杂性 •设计单入口和单出口的模块 •模块功能应该可以预测 \\1. 改进软件结构提高模块独立性 •降低耦合 •提高内聚 \\2. 模块规模应该适中 •模块规模： 不超过60行 超过30，可理解程度迅速下降 •模块数量： 适中 模块过大：往往是由于分解不充分。 模块过小：导致模块数目过多，使系统接口复杂。可以把它合并到上级模块中去。 \\3. 深度、宽度、扇出和扇入都应适当 • 深度：表示软件结构中控制的层数。 ​ 能粗略地标志一个系统的大小和复杂程度。如果层数过多，应考虑管理模块是否过分简单，能否适当合并。 • 宽度：软件结构内同一个层次上的模块总数的最大值。 ​ 宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。 • 扇出：是一个模块直接控制(调用)的模块数目。 ​ 扇出过大意味着模块过分复杂，需要控制和协调的下级模块过多；扇出过小(例如总是1)也不好。 ​ 通常是3或4(上限是5～9)。 扇出太大：缺乏中间层次，应适当增加中间层次的控制模块。 扇出太小：把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。 ​ 分解或合并模块应符合问题结构，不能违背模块独立原理。 • 扇入：表明有多少个上级模块。扇入越大则共享该模块的上级模块数目越多，这是有好处的。 ​ 好的软件结构通常顶层扇出比较高，中层扇出较少，底层模块有高扇入。 ​ 系统的模块结构呈现为“葫芦形”。 \\4. 模块的作用域应该在控制域之内 • 模块的作用域：受该模块内一个判定影响的所有模块的集合。 • 模块的控制域：模块本身以及所有直接或间接从属于它的模块的集合。 ​ 例如，在图5.2中模块A的控制域是A、B、C、D、E、F等模块的集合。 ​ 受判定影响的模块应在做出判定的那个模块的控制域之内。 图5.2 模块的作用域和控制域 \\5. 力争降低模块接口的复杂程度 ​ 应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。 \\6. 设计单入口单出口的模块 ​ 使模块间避免出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。 \\7. 模块功能应该可以预测 ​ 只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。 ​ 带有内部“存储器”的模块的功能可能是不可预测的，不宜测试与维护。 5.4 描绘软件结构的图形工具 5.4.1 层次图和HIPO图 层次图：用来描绘软件的层次结构。 ​ 形式和描绘数据结构的层次方框图相同，但表现的内容却完全不同。 •层次图中的一个矩形框代表一个模块，方框间的连线表示调用关系 •层次方框图中的一个矩形框代表数据的子集，方框间的连线表示组成关系。 图5.3是层次图的一个例子。 图5.3 正文加工系统的层次图 HIPO： “层次图加输入/处理/输出图”的英文缩写。 ​ 为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。编号规则和数据流图的编号规则相同。 例如，图5.3加了编号后得到图5.4。 ​ H图中每个方框对应一张IPO图，描绘这个方框代表的模块的处理过程。每张IPO图内都应标出它所描绘的模块在H图中的编号。 图5.4 带编号的层次图(H图) 5.4.2 结构图 ​ 结构图和层次图类似，也是描绘软件结构的图形工具。 结构图基本符号： •方框——模块 •方框间连线——模块调用关系（上方的模块调用下方的模块） •带注释的箭头——模块间传递的信息 •箭头尾部空心圆——数据信息 •箭头尾部实心圆——控制信息 图5.5 结构图的例子——产生最佳解的一般结构 ​ 还有一些附加的符号，可以表示模块的选择调用或循环调用。 图5.6 判定为真时调用A，为假时调用B 图5.7 模块M循环调用模块A、B、C 5.5 面向数据流的设计方法 5.5.1 概念 面向数据流的设计方法：把数据流图中的信息流映射成软件结构。信息流的类型决定了映射的方法。信息流有下述两种类型。 \\1. 变换流 变换流：具有较明显的输入、变换（或称主加工）和输出界面的数据流图。 参看图5.8 图5.8 变换流 \\2. 事务流 事务流：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。 此时数据流图形状如图5.9，是“以事务为中心的”。 图5.9中的处理T称为事务中心，它完成下述任务： (1) 接收输入数据(输入数据又称为事务)； (2) 分析每个事务以确定它的类型； (3) 根据事务类型选取一条活动通路。 图5.9 事务流 \\3. 设计过程 ​ 图5.10（见书96页）说明了使用面向数据流方法逐步设计的过程。 5.5.2 变换分析 变换分析：把数据流图按预先确定的模式映射成软件结构的一系列设计步骤的总称。 下面通过一个例子说明变换分析的方法。 \\1. 例子 考虑汽车数字仪表板的设计。 假设的仪表板将完成下述功能： (1) 通过模数转换实现传感器和微处理机接口； (2) 在发光二极管面板上显示数据； (3) 指示每小时英里数(mph)，行驶的里程，每加仑油行驶的英里数(mpg)等等； (4) 指示加速或减速； (5) 超速警告：如果车速超过55英里/小时，则发出超速警告铃声。 在需求分析阶段建立起相应的数据流图。 \\2. 设计步骤 第1步 复查基本系统模型。 复查的目的是确保系统的输入数据和输出数据符合实际。 第2步 复查并精化数据流图。 应该对需求分析阶段得出的数据流图认真复查，并且在必要时进行精化。使数据流图中每个处理都代表一个规模适中相对独立的子功能。 假设在需求分析阶段产生的数字仪表板系统的数据流图如图5.11（见书97页）所示。 第3步 确定数据流图具有变换特性还是事务特性。 ​ 一般地说，一个系统中的所有信息流都可以认为是变换流，但是，当遇到有明显事务特性的信息流时，建议采用事务分析方法进行设计。 ​ 从图5.11看出，数据沿着两条输入通路进入系统，然后沿着5条通路离开，没有明显的事务中心。 ​ 因此可以认为这个信息流具有变换流的总特征。 第4步 确定输入流和输出流的边界，从而孤立出变换中心。 ​ 对于汽车数字仪表板的例子，设计人员确定的流的边界如图5.12（见书98页）所示。 第5步 完成“第一级分解”。 分解：就是分配控制的过程，对控制的自顶向下的分配----软件结构。 ​ 图5.13说明了第一级分解的方法。位于软件结构最顶层的控制模块Cm协调下述从属的控制功能： 输入信息处理控制模块Ca：协调对所有输入数据的接收； 变换中心控制模块Ct：管理对内部形式的数据的所有操作； 输出信息处理控制模块Ce：协调输出信息的产生过程。 ​ 数据流图被映射成一个特殊的软件结构，这个结构控制输入、变换和输出等信息处理过程。 图5.13 第一级分解的方法 ​ 对于数字仪表板的例子，第一级分解得出的结构如图5.14所示。每个控制模块的名字表明了为它所控制的那些模块的功能。 图5.14 数字仪表板系统的第一级分解 第6步 完成“第二级分解”。 第二级分解：就是把数据流图中的每个处理映射成软件结构中一个适当的模块。 完成第二级分解的方法是： •从变换中心的边界开始沿着输入通路向外移动，把输入通路中每个处理映射成软件结构中Ca控制下的一个低层模块； •然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块Ce控制的一个低层模块； •最后把变换中心内的每个处理映射成受Ct控制的一个模块。 ​ 图5.15表示进行第二级分解的普遍途径。 图5.15 第二级分解的方法 ​ 对于数字仪表板系统的例子，第二级分解的结果分别用图5.16，5.17和5.18描绘。 ​ 这3张图表示对软件结构的初步设计结果。 图5.16 未经精化的输入结构 图5.17 未经精化的变换结构 图5.18 未经精化的输出结构 第7步 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。 根据模块独立原理进行精化。得到尽可能高的内聚、尽可能松散的耦合。需对初步分割得到的模块进行再分解或合并。 ​ 具体到数字仪表板的例子，对于从前面的设计步骤得到的软件结构，还可以做许多修改： • 输入结构中的模块“转换成rpm”和“收集sps”可以合并； • 模块“确定加速/减速”可以放在模块“计算mph”下面，以减少耦合； • 模块“加速/减速显示”可以相应地放在模块“显示mph”的下面。 经过上述修改后的软件结构画在图5.19中。 图5.19 精化后的数字仪表板系统的软件结构 5.5.3 事务分析 ​ 在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。 事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于： ​ 由数据流图到软件结构的映射方法不同。 ​ 由事务流映射成的软件结构包括一个接收分支和一个发送分支。 • 接收分支结构 ​ 映射方法和变换分析映射出输入结构的方法很相像。 ​ 从事务中心的边界开始，把沿着接收流通路的处理映射成模块。 • 发送分支结构 ​ 包含一个调度模块，它控制下层的所有活动模块； ​ 然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构。 ​ 图5.20说明了上述映射过程。 图5.20 事务分析的映射方法 5.5.4 设计优化 ​ 对第一次分割得到的软件结构，总可以根据模块独立原理和启发式设计规则进行优化。 为了产生合理的分解，得到尽可能高的内聚﹑尽可能松散的耦合，最重要的是，为了得到一个易于实现﹑易于测试和易于维护的软件结构，应该对初步分割得到的模块进行再分解或合并。 ​ 注意，设计优化应该力求做到在有效的模块化的前提下使用最少量的模块，以及在能够满足信息要求的前提下使用最简单的数据结构。 5.6 小结 总体设计阶段的基本目的：是用比较抽象概括的方式确定系统如何完成预定的任务，确定系统的物理配置方案，确定组成系统的每个程序的结构。 总体设计阶段主要由两个小阶段组成。 首先需要进行系统设计；然后进行软件结构设计，确定软件由哪些模块组成以及这些模块之间的动态调用关系。 层次图和结构图是描绘软件结构的常用工具。 在进行软件结构设计时应该遵循的最主要的原理是模块独立原理。 抽象和求精是一对互补的概念。在进行软件结构设计时就是由抽象到具体地构造出软件的层次结构。 软件工程师在开发软件的长期实践中积累了丰富的经验，总结这些经验得出一些很有参考价值的启发式规则。 自顶向下逐步求精是进行软件结构设计的常用途径； 如果已经有了详细的数据流图，也可以使用面向数据流的设计方法，由数据流图映射出软件结构。 ​ 这样映射出来的只是软件的初步结构，还必须根据设计原理并且参考启发式规则，认真分析和改进软件的初步结构，以得到质量更高的模块和更合理的软件结构。 "},"page/1017.html":{"url":"page/1017.html","title":"详细设计","keywords":"","body":"详细设计 第6章 详细设计 详细设计的目标： ​ 得出对目标系统的精确描述，从而在编码阶段可以把这个描述直接翻译成用某种程序设计语言书写的程序。 对目标系统的精确描述： •详细的算法 •数据表示和数据结构 •实施的功能和使用的数据之间的关系 ​ 详细设计的任务： • 逻辑上正确地实现每个模块的功能。 • 设计出的处理过程应该尽可能简明易懂。（更重要） ​ 面向过程的详细设计是基于结构化的程序设计技术，结构化程序设计技术是面向过程的详细设计的逻辑基础。 ​ 结构化程序设计技术是实现上述任务的关键技术。 ​ 6.1 结构程序设计 •E.W.Dijkstra在60年代中期提出结构程序设计的概念 •结构化程序设计技术：采用自顶向下逐步求精的设计方法和单入口单出口的控制结构，并且只包含顺序、选择和循环三种结构。 •C.Bohm和G.Jacopini在数学上证明了只用“顺序”、“选择”和“循环”这三种基本的控制结构可以实现任何单入口和单出口的程序 6.1 3种基本的控制结构 • 经典的结构程序设计：只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这3种基本控制结构； • 扩展的结构程序设计：除了上述3种基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构； • 修正的结构程序设计：除上述结构以外，还允许使用LEAVE(或BREAK)结构。 ​ 结构程序设计是尽可能少用GO TO语句的程序设计方法。仅在检测出错误时才使用GO TO语句，而且总是使用前向GO TO语句。 图6.2 其他常用的控制结构 6.3 过程设计的工具 6.3.1 程序流程图 程序流程图（程序框图）：描述过程设计的方法，也是用得最混乱的一种方法。 优点：对控制流程的描绘很直观，便于初学者掌握。 缺点： (1) 不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。 (2) 用箭头代表控制流，程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。 (3) 不易表示数据结构。 使用对策：只用结构程序设计允许的五种图示结构 6.3.2 盒图(N-S图) 一种不允许违背结构程序设计精神的图形工具。又称为N-S图。它有下述特点： (1) 功能域(作用域)明确，可以从盒图上一眼就看出来。 (2) 不可能任意转移控制。 (3) 很容易确定局部和全程数据的作用域。 (4) 很容易表现嵌套关系，也可以表示模块的层次结构。 看图6.4 盒图没有箭头，因此不允许随意转移控制。 图6.4 盒图的基本符号 6.3.3 PAD图 PAD是问题分析图(problem analysis diagram) 。 ​ 它用二维树形结构的图来表示程序的控制流。 图6.5给出PAD图的基本符号。 图6.5 PAD图的基本符号 PAD图的主要优点如下： (1) 使用PAD符号设计的程序必然是结构化程序。(2) PAD图所描绘的程序结构十分清晰。 最左面的竖线是程序的主线，即第一层结构。 随着程序层次的增加，PAD图逐渐向右延伸。 ​ 每增加一个层次，图形向右扩展一条竖线。图中竖线的总条数就是程序的层次数。 (3) PAD图表现的程序逻辑，易读、易懂、易记。 ​ 程序从图中最左竖线上端的结点开始执行，自上而下，从左向右顺序执行，遍历所有结点。 (4) 容易将PAD图转换成高级语言源程序，这种转换可用软件工具自动完成。 (5) 即可表示程序逻辑，也可描绘数据结构。 (6) 支持自顶向下、逐步求精方法的使用。 ​ 开始时可以定义一个抽象的程序，随着设计的深入，使用def符号逐步增加细节，直至完成详细设计，如图6.6所示。 图6.6 使用PAD图提供的定义功能来逐步求精的例子 示例 6.3.4 判定表 ​ 适于表示复杂的条件组合与应做的动作之间的对应关系。 一张判定表由以下四部分组成： ​ (1)左上部列出所有条件。 ​ (2)左下部是所有可能的动作。 ​ (3)右上部是表示各种条件组合的一个矩阵。 ​ (4)右下部是和每种条件组合相对应的动作。 判定表右半部的每一列实际上就是一个规则，规定了与特定的条件组合相对应的动作。 示例： ​ 假设某大学要从学生中挑选男子篮球队队员， 基本条件是： 各门课程的平均分在70分以上， 身高超过1．80米， 体重超过75千克。 需要从学生登记表中挑选出符合上述条件的男同学，并列出他们的姓名和住址，以便进一步选拔。 用判定表表示上述条件和动作之间的关系。 以行李托运费的算法为例： 假设某航空公司规定，乘客可以免费托运重量不超过30kg的行李。 当行李重量超过30kg时， 对头等舱的国内乘客超重部分每公斤收费4元， 对其他舱的国内乘客超重部分每公斤收费6元， 对外国乘客超重部分每公斤收费比国内乘客多一倍， 对残疾乘客超重部分每公斤收费比正常乘客少一半。 ​ 用判定表可以清楚地表示与上述每种条件组合相对应的计算行李费的算法。见书118页表6.1 。 6.3.5 判定树 ​ 初次接触判定表的人理解它需要一个简短的学习过程。 ​ 判定树是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。 判定树的优点： 形式简单到不需任何说明，一眼就可以看出其含义，易于掌握和使用。 图6.7 用判定树表示计算行李费的算法 6.3.6 过程设计语言 过程设计语言（PDL）也称为伪码。 它是用正文形式表示数据和处理过程的设计工具。 PDL的优点： • 可以作为注释直接插在源程序中间。 • 可以使用普通的正文编辑程序或文字处理系统，方便地完成书写和编辑工作。 • 已经有自动处理程序存在，可以自动生成程序代码。 PDL的缺点： • 是不如图形工具形象直观， • 描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。 类程序设计语言（PDL） LOOP:Set I to (START+FINISH)/2 If TABLE(I)=ITEM got FOUND If TABLE(I)ITEM Set FINISH to (I-1) If(FINISH-START)>1 goto LOOP If TABLE(START)=ITEM got FOUND If TABLE(FINISH)=ITEM got FOUND Set FLAG to 0 Goto DONE FOUND:Set FLAG to 1 DONE:Exit 6.4 面向数据结构的设计方法 6.4.1 Jackson图 ​ 数据元素彼此间的逻辑关系只有顺序、选择和重复3类，因此，逻辑数据结构也只有这3类。 顺序结构 顺序结构的数据：由一个或多个数据元素组成，每个元素按确定次序出现一次。 图6.8 图6.8 A由B、C、D 3个元素顺序组成 \\2. 选择结构 选择结构的数据：包含两个或多个数据元素，每次使用这个数据时按一定条件从这些数据元素中选择一个。 图6.9 图6.9 根据条件A是B或C或D中的某一个 \\3. 重复结构 重复结构的数据：根据使用时的条件由一个数据元素出现零次或多次构成。 图6.10 图6.10 A由B出现N次(N≥0)组成 6.4.2 改进的Jackson图 上一小节介绍的Jackson图的缺点是： • 表示选择或重复结构时，选择条件或循环结束条件不能直接在图上表示出来； • 框间连线为斜线，不易在行式打印机上输出。 改进Jackson图 见图6.11 图6.11 改进的Jackson图 ​ Jackson图和描绘软件结构的层次图形式类似，但是含义却很不相同： • 层次图中的一个方框通常代表一个模块； • Jackson图的一个方框只代表几个语句。 • 层次图表现的是调用关系，通常一个模块除了调用下级模块外，还完成其他操作； •Jackson图表现的是组成关系，一个方框中包括的操作仅仅由它下层框中的那些操作组成。 6.4.3 Jackson法 Jackson结构程序设计方法基本上由下述5个步骤组成。 (1) 分析并确定输入数据和输出数据的逻辑结构，并用Jackson图描绘这些数据结构。 (2) 找出输入数据结构和输出数据结构中有对应关系的数据单元。 (3) 用下述3条规则从描绘数据结构的Jackson图导出描绘程序结构的Jackson图。 　　① 为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框 　　② 根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。 　　③ 根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。 (4) 列出所有操作和条件(包括分支条件和循环结束条件)，并且把它们分配到程序结构图的适当位置。 (5) 用伪码表示程序。 Jackson方法中使用的伪码和Jackson图是完全对应的，下面是和3种基本结构对应的伪码。 顺序结构A seqBCDA end 选择结构 A select cond1 B A or cond2 C A or cond3 D A end 重复结构 A iter until(或while) cond B A end 下面结合一个具体例子进一步说明Jackson结构程序设计方法。 例：一个正文文件由若干个记录组成，每个记录是一个字符串。要求统计每个记录中空格字符的个数，以及文件中空格字符的总个数。要求的输出数据格式是，每复制一行输入字符串之后，另起一行印出这个字符串中的空格数，最后印出文件中空格的总个数。 输入和输出数据的结构很容易确定，用Jackson图描绘的输入输出数据结构 导出描绘程序结构的Jackson图 统计空格个数需要的全部操作和条件如下： (1)停止 　　　　　　 (2) 打开文件 (3) 关闭文件　　　　 (4) 印出字符串 (5) 印出空格数目　　 (6) 印出空格总数 (7) sum∶=sum+1　　(8) totalsum∶=totalsum+sum (9) 读入字符串 　　　(10) sum∶=0 (11) totalsum∶=0 　 (12) pointer∶=1 (13) pointer∶=pointer+1 I(1) 文件结束 I(2) 字符串结束 S(3) 字符是空格 经过简单分析不难把这些操作和条件分配到程序结构图的适当位置： 统计空格seq 打开文件 读入字符串totalsum∶=0 程序体iter until文件结束 处理字符串seq 印字符串seq 印出字符串 印字符串end sum∶=0 pointer∶=1 分析字符串iter until字符串结束 分析字符select字符是空格 处理空格Seq sum∶=sum+1 pointer∶=pointer+1 处理空格end 分析字符or字符不是空格 处理非空格seq pointer∶=pointer+1 处理非空格end 分析字符end 分析字符串end 印空格数seq 印出空格数目 印空格数end totalsum∶=totalsum+sum 读入字符串 处理字符串end 程序体end 印总数seq 印出空格总数 印总数end 关闭文件 停止 统计空格end 6.5 程序复杂程度的定量度量 •定量度量的意义：把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量，定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣；程序的定量的复杂程度可以作为模块规模的精确限度。 度量方法： McCabe Halstead 6.5.1 McCabe方法 •程序的环形复杂度：McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度。 •流图：退化的程度流程图，仅仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。 •计算环形复杂度的方法 •环形复杂度的用途 •圆表示结点，代表一条或者多条语句。 程序流程图中一个顺序的处理框序列和一个菱形判定框可以映射成流图中的一个结点。 •箭头线称为边，代表控制流。 一条边必须终止于一个结点。 •区域，边和结点围成的面积。 计算区域数时应该包括图外部未被围起来的区域。 图6.16 由PDL翻译成的流图 图6.17 由包含复合条件的PDL映射成的流图 2. 计算环形复杂度的方法 3种方法： •V(G) = D D，区域数 •V(G) = P + 1 P，判定结点的数目 •V(G) = E – N + 2 E，边的条数 N，结点数 3. 环形复杂度的用途 •预测测试难度 •预测软件可靠性 •V(G)高的程序难于实现，容易出错 •模块规模参考V(G)≤10 6.2 人机界面设计 ​ 人机界面设计是接口设计的一个重要的组成部分。其设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命。 6.2.1 人机界面设计问题 存在的4个问题： ​ 系统响应时间； ​ 用户帮助设施； ​ 出错信息处理； ​ 命令交互。 \\1. 系统响应时间 系统响应时间：指从用户完成某个控制动作(例如，按回车键或点击鼠标)，到软件给出预期的响应(输出信息或做动作)之间的这段时间。 系统响应时间的两个重要属性：长度和易变性。 长度： 响应时间过长：用户就会感到紧张和沮丧。 响应时间过短：加快用户操作节奏，易犯错误。 易变性：指系统响应时间相对于平均响应时间的偏差。易变性低有助于用户建立起稳定的工作节奏。 \\2. 用户帮助设施 ​ 应提供联机帮助设施，这使得用户无须离开用户界面就能解决自己的问题。 常见的帮助设施可分为： •集成的：设计在软件里面，它对用户工作内容是敏感的，可以缩短用户获得帮助的时间，增加界面的友好性。 •附加的：在系统建成后再添加到软件中的，实际上是一种查询能力有限的联机用户手册。 集成的优于附加的。 \\3. 出错信息处理 出错信息或警告信息应具有的属性： (1) 用用户可以理解的术语描述问题； (2) 提供有助于从错误中恢复的建设性意见； (3) 指出错误可能导致哪些负面后果(例如，破坏数据文件)； (4) 伴随听觉或视觉给与提示。例如，在危险操作时发出警告铃声。 (5) 不能带有指责色彩。 \\4. 命令交互 可提供二种操作方式：菜单，键盘。 6.2.2 人机界面设计过程 是一个迭代的过程。 ​ 先创建设计模型， ​ 再用原型实现这个设计模型， ​ 由用户试用和评估， ​ 根据用户意见进行修改。 6.2.3 人机界面设计指南 \\1. 一般交互指南 • 在执行有较大破坏性的动作之前要求用户确认。 • 允许取消绝大多数操作。应能方便地取消已完成的操作。 • 减少在两次操作之间必须记忆的信息量。 • 提高对话、移动和思考的效率。应该尽量减少用户击键的次数，设计屏幕布局时应该考虑尽量减少鼠标移动的距离，尽量避免出现用户问“这是什么意思?”的情况。 • 提供对用户工作内容敏感的帮助设施。 \\2. 信息显示指南 • 只显示与当前工作内容有关的信息。 • 用直观的方式来表示数据。例如，用图形或图表来取代庞大的表格。 \\3. 数据输入指南 • 保持信息显示和数据输入之间的一致性 • 使在当前动作语境中不适用的命令不起作用。这可使得用户不去做那些肯定会导致错误的动作。 • 对所有输入动作都提供帮助。 • 消除冗余的输入。不要求用户指定输入数据的单位；尽可能提供默认值。 "},"page/1018.html":{"url":"page/1018.html","title":"实现（编码和测试）","keywords":"","body":"实现（编码和测试） 第7章 实现 实现：编码和测试的统称。 编码：把软件设计结果翻译成用某种程序设计语言书写的程序。 程序的质量主要取决于： • 软件设计的质量。 • 所选用的程序设计语言的特点及编码风格也将对程序的可靠性、可读性、可测试性和可维护性产生深远的影响。 • 软件测试也是保证软件质量的关键步骤，它是对软件规格说明、设计和编码的最后复审。 7.1 编码 7.1.1 选择程序设计语言 • 编码之前的一项重要工作： ​ 就是选择一种适当的程序设计语言。 • 高级语言 ​ 用高级语言写的程序容易阅读，容易测试，容易调试，容易维护。 选用高级语言的实用标准： (1) 系统用户的要求。选择用户熟悉的语言。 (2) 可以使用的编译程序。运行目标系统的环境中可提供的编译程序往往限制了所选用语言的范围。 (3) 可以得到的软件工具。某种语言是否有支持程序开发的软件工具可以利用。 (4) 工程规模。 (5) 程序员的知识。应该选择一种已经为程序员所熟悉的语言。 (6) 软件可移植性要求。 (7) 软件的应用领域。 7.1.2 编码风格 好程序的标准： ​ 代码的逻辑：简明清晰、易读易懂。 故编码应该遵循下述规则： • 程序内部的文档 • 数据说明 • 语句构造 • 输入输出 • 效率 • 程序内部的文档 程序内部的文档包括：恰当的标识符、适当的注解 和程序的视觉组织等。 • 含义鲜明的名字 • 正确的注解 • 缩写规则一致 ​ 程序清单的布局对于程序的可读性也有很大影 响，应该利用适当的阶梯形式使程序的层次结构 清晰明显。 数据说明 •数据说明的次序应该标准化。 ​ 有次序就容易查阅，因此能够加速测试、调试和维护的过程。 ​ 先按类型 ​ 再按字母 •复杂的数据结构，应该用注解说明用程序设计语言实现这个数据结构的方法和特点。 \\3. 语句构造 •简单而直接 不要为了节省空间而把多个语句写在同一行； 尽量避免使用复杂的条件； 尽量减少使用“非”条件； 避免大量使用循环嵌套和条件嵌套； 利用括号使逻辑表达式或算术表达式的运算次序清晰直观。 \\4. 输入输出 •对所有输入数据都进行检验； •检查输入项重要组合的合法性； •保持输入格式简单； •使用数据结束标记，不要要求用户指定数据的数目； •明确提示交互式输入的请求，详细说明可用的选择或边界数值； •当程序设计语言对格式有严格要求时，应保持输入格式一致； •设计良好的输出报表； •给所有输出数据加标志。 效率 主要讨论程序运行时间和输入输出对效率的影响。 (1) 输入输出的效率 ​ 简单清晰是提高人机通讯效率的关键。 ​ 如输入输出很难被人理解，将降低效率。 (2) 程序运行时间 影响源程序的效率的因素： •算法的效率； •写程序的风格。（对程序的执行速度和存储器要求产生影响） 因此写程序时可应用下述规则： 写程序时可应用下述规则： •写程序之前先简化算术的和逻辑的表达式； •仔细研究嵌套的循环，以确定是否有语句可以从内层往外移； •尽量避免使用多维数组； •尽量避免使用指针和复杂的表； •使用执行时间短的算术运算； •不要混合使用不同的数据类型； •尽量使用整数运算和布尔表达式。 为什么要有编码规范 编码规范对于程序员而言尤为重要，原因： • 一个软件的生命周期中，80%的花费在于维护； •几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护； •编码规范可以改善软件的可读性，可以让程序员尽快而彻底地理解新的代码。 ​ 为了执行规范，每个软件开发人员必须一致遵守编码规范。 7.2 软件测试基础 7.2.1 软件测试的目标 G.Myers给出了关于测试的一些规则，这些规则也可以看作是测试的目标或定义。 (1) 测试是为了发现程序中的错误而执行程序的过程； (2) 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案； (3) 成功的测试是发现了至今为止尚未发现的错误的测试。 测试是在精心控制的环境下执行程序，以发现程序中的错误，给出程序可靠性的鉴定。 7.2.1 软件测试的目标 •测试的正确定义是：“为了发现程序中的错误而执行程序的过程”。 •错误的认识： ​ “测试是为了表明程序是正确的”， ​ “成功的测试是没有发现错误的测试” 。 •正确认识测试的目标是十分重要的，测试目标决定了测试方案的设计。 ​ 如果为了表明程序的正确，就会设计一些不易暴露错误的测试方案； ​ 如果是为了发现程序中的错误，就会设计出最能暴露错误的测试方案。 7.2.2 软件测试准则 （1） 所有测试都应该能追溯到用户需求。 ​ 软件测试的目标是发现错误，最严重的错误是导致程序不能满足用户需求。 （2） 应该远在测试开始之前就制定出测试计划。 ​ 在完成需求模型时，就着手制定测试计划， ​ 在建立了设计模型后，就开始设计详细的测试方案。 （3） 应该从“小规模”测试开始，并逐步进行“大规模”测试。 ​ 先测试单个程序模块，再测试集成模块，最后在整个系统中寻找错误。 （4） 应该由独立的第三方从事测试工作。 ​ 软件工程师不能承担全部测试工作，主要承担模块测试工作。 （5） 穷举测试是不可能的。 穷举测试：把程序所有可能的执行路径都检查一遍的测试。 ​ 即使是一个中等规模的程序，其执行路径的排列数也十分庞大。因此，测试只能证明程序中有错误，不能证明程序中没有错误。 • 假设一个程序P有输入量X和Y及输出量Z。在字长为32位的计算机上运行。若X、Y取整数，按黑盒方法进行穷举测试： • 可能采用的 测试数据组： ​ 232×232 ​ ＝264 •如果测试一组数据需要1毫秒，一年工作365×24小时，完成所有测试需5亿年。 7.2.3 测试方法 •黑盒测试：指在软件界面上进行的测试。一般用来证实软件功能的可操作性；证实能很好的接收输入，并正确地产生输出；以及证实对外部信息完整性的保持。 •白盒测试：对程序细节进行严密检验，对软件的逻辑路径进行测试。 黑盒测试法：把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。只检查程序功能是否按照规格说明书的规定正常使用。 黑盒测试又称为功能测试。 白盒测试法：把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法，用于检测程序中的主要执行通路是否都能按预定要求正确工作。 白盒测试又称为结构测试。 7.2.4 测试步骤 \\1. 模块测试 ​ 把每个模块作为一个单独的实体来测试。 ​ 模块测试通常又称为单元测试。在测试中所发现的往往是编码和详细设计的错误。 \\2. 子系统测试 ​ 把经过单元测试的模块放在一起形成一个子系统来测试。 ​ 模块相互间的协调和通信是这个测试过程中的主要问题，着重测试模块的接口。 \\3. 系统测试 ​ 把经过测试的子系统装配成一个完整的系统来测试。 ​ 验证系统能否提供需求说明书中指定的功能，动态特性是否符合预定要求。其中发现的往往是软件设计中的错误，也可能是需求说明中的错误。 ​ 子系统测试和系统测试，都兼有检测和组装两重含义，通常称为集成测试。 \\4. 验收测试 ​ 把软件系统作为单一的实体进行测试，测试内容与系统测试基本类似，但它是在用户积极参与下进行的，而且主要使用实际数据进行测试。 ​ 目的是验证系统确实能够满足用户的需要，其中发现的往往是系统需求说明书中的错误。 ​ 验收测试也称为确认测试。 \\5. 平行运行 平行运行：就是同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。 这样做的具体目的有如下几点： (1) 可以在准生产环境中运行新系统而又不冒风险； (2) 用户能有一段熟悉新系统的时间； (3) 可以验证用户指南和使用手册之类的文档； (4) 能够以准生产模式对新系统进行全负荷测试，进一步验证性能指标。 7.2.5 测试阶段的信息流 测试阶段的的输入信息有两类： (1)软件配置，包括需求说明书、设计说明书和源程序清单等； (2)测试配置，包括测试计划和测试方案。 测试方案包括： •测试用例：测试时使用的输入数据； •每组输入数据预定要检验的功能，以及每组输入数据预期应该得到的正确输出。 ​ 图7.1 ​ 测试结果和预期结果不一致，程序中可能有错误，进入调试阶段。由程序的编写者负责调试。 图7.1 测试阶段的信息流 •如果经常出现要求修改设计的严重错误，那么软件的质量和可靠性是值得怀疑的。 •如果软件功能完成得很正常，遇到的错误也很容易改正，仍然应该考虑两种可能： (1)软件的可靠性是可以接受的； (2)所进行的测试尚不足以发现严重的错误。 •如果经过测试，一个错误也没有被发现，则很可能是对测试配置思考不充分，以致不能暴露软件中潜藏的错误。 7.3 单元测试 ​ 单元测试主要使用白盒测试技术，而且对多个模块的测试可以并行地进行。 7.3.1 测试重点 \\1. 模块接口 ​ 首先应该对通过模块接口的数据流进行测试，如果数据不能正确地进出，所有其他测试都是不切实际的。 \\2. 局部数据结构 局部数据说明、初始化、默认值等方面是否正确。 \\3. 重要的执行通路 由于不可能进行穷尽测试，在单元测试期间选择最有代表性、最可能发现错误的执行通路进行测试。 \\4. 出错处理通路 ​ 好的设计应该能预见出现错误的条件，并且设置适当的处理错误的通路。 ​ 应该认真测试这种通路能否正确运行。 \\5. 边界条件 ​ 边界测试在单元测试中非常重要。软件常常在它的边界上失效。 ​ 使用刚好小于、刚好等于和刚好大于最大值或最小值的测试方案，非常可能发现软件中的错误。 测试的过程 •程序的测试一般按三种方式进行： 静态分析 动态测试 自动测试 •测试的过程，先进行静态分析，然后进行动态测试；在某些特殊情况下，也可以借助自动测试工具对程序进行查错。 •静态分析：是指不执行程序，而只由人工对程序文本进行检查，通过阅读和讨论，分析和发现程序中的错误。 •静态分析是一种卓有成效的测试方法，大约30％—70％的逻辑设计错误和编码错误可以通过静态分析检查出来。又称代码审查。 7.3.2 代码审查 •讨论：是由一些有经验的测试人员阅读程序文本及有关文档，对程序的结构与功能、数据的结构、接口、控制流以及语法进行讨论和分析，从而揭示程序中的错误。 •走查：是由测试人员用一些测试用例沿程序逻辑运行，并随时记录程序的踪迹；然后进行分析，发现程序中的错误。 测试的过程 •程序的动态分析： 使用测试用例在计算机上运行程序，使程序在运行过程中暴露错误。 •自动测试工具： 是人们编制的用于测试的软件，并用它来代替人工测试。 7.3.3 计算机测试 ​ 模块并不是一个独立的程序，因此必须为每个单元测试开发驱动软件和(或)存根软件。 •驱动程序：也称“主程序”，它接收测试数据，把这些数据传送给被测试的模块，并且印出有关的结果。 •存根程序：也称“虚拟子程序”，代替被测试的模块所调用的模块。 ​ 它使用被它代替的模块的接口，可能做最少量的数据操作，印出对入口的检验或操作结果，并且把控制归还给调用它的模块。 对最小的软件设计单元——模块的验证工作 例：图7.2是一个正文加工系统的部分层次图，假定要测试其中编号为3.0的关键模块——正文编辑模块。 •需要有一个测试驱动程序来调用它。 ​ 说明必要的变量，接收测试数据——字符串，并且设置正文编辑模块的编辑功能。 •存根程序简化地模拟下层模块，完成具体的编辑功能。可只用一个存根程序模拟正文编辑模块的所有下层模块。 图7.2 正文加工系统的层次图 代码审查比计算机测试优越之处： •一次审查会上可以发现许多错误； •用计算机测试的方法发现错误之后，通常需要先改正这个错误才能继续测试，因此错误是一个一个地发现并改正的。 ​ 人工测试和计算机测试互相补充，相辅相成，缺少其中任何一种方法都会使查找错误的效率降低。 7.4 集成测试 集成测试：把模块按照设计要求组装起来的同时进行测试。 主要目标:是发现与接口有关的问题。与系统测试类似。 组装模块有两种方法： 1.非渐增式测试（整体拼装）： 首先对每个模块分别进行模块测试，然后再把所有模块组装在一起进行测试，最终得到要求的软件系统； 2.渐增式测试（增量集成）： •首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统； •在组装的过程中边连接边测试，以发现连接过程中产生的问题 •通过增殖逐步组装成为要求的软件系统。 两种方法优缺点： 非渐增式测试： ​ 一下子把所有模块放在一起，并把庞大的程序作为一个整体来测试，测试者面对的情况十分复杂，会遇到许多错误，改正错误更是极端困难。而且改正一个错误之后，马上又会遇到新的错误。 渐增式测试： ​ 它把程序划分成小段来构造和测试，比较容易定位和改正错误；对接口可以进行更彻底的测试。 ​ 故普遍采用渐增式测试方法。 ​ 当使用渐增方式组装模块时，有自顶向下和自底向上两种集成策略。 7.4.1 自顶向下集成 •将模块按系统程序结构，沿控制层次自顶向下进行组装。从主控制模块开始。 •在测试过程中较早地验证了主要的控制和判断点。 •选用按深度方向测试的方式，可以首先实现和验证一个完整的软件功能。 • 或使用深度优先策略，或使用宽度优先策略。 7.4.1 自顶向下集成 由下述4个步骤完成： 第一步，对主控制模块进行测试，测试时用存根程序代替所有直接附属于主控制模块的模块； 第二步，根据选定的结合策略(深度优先或宽度优先)，每次用一个实际模块代换一个存根程序； 第三步，在结合进一个模块的同时进行测试； 第四步，为了保证加入模块没有引进新的错误，需要进行回归测试(全部或部分地重复以前做过的测试)。 上述第二步到第四步实质上构成了一个循环． 图7.3 自顶向下宽度优先结合 7.4.2 自底向上集成 •从程序模块结构的最底层的模块（ 原子模块）开始组装和测试。 •因为是自底向上组装模块，对于一个给定层次的模块，它的子模块已经组装并测试完成，所以不再需要存根程序。在测试过程中需要从子模块得到的信息可以直接运行子模块得到。 用下述四个步骤完成： 第一步，把低层模块组合成实现某个特定的软件子功能的族； 第二步，写一个驱动程序，协调测试数据的输入和输出； 第三步，对由模块组成的子功能族进行测试； 第四步，去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。 上述第二步到第四步实质上构成了一个循环。图7.4 　如果软件结构的顶部两层用自顶向下的方法组装，可以明显减少驱动程序的数目，而且族的结合也将大大简化。 图7.4 自底向上结合 7.4.3 不同集成测试策略的比较 ​ 自顶向下测试方法的优点： •不需要测试驱动程序， •能够在测试阶段的早期实现并验证系统的主要功能， •能在早期发现上层模块的接口错误。 ​ 自顶向下测试方法的缺点： •是需要存根程序， •低层关键模块中的错误发现较晚， •用这种方法在早期不能充分展开人力。 ​ 自底向上优缺点与自顶向下刚好相反。 通常采用混合策略： (1) 改进的自顶向下测试方法。 •基本上使用自顶向下的测试方法， •早期，对少数关键模块使用自底向上的测试方法。 优点： •具备自顶向下方法的优点； •能在测试的早期发现关键模块中的错误； 缺点： •测试关键模块时需要驱动程序。 (2) 混合法。 •较上层使用的自顶向下方法； •较下层使用的自底向上方法。 兼有两种方法的优点和缺点，最好的折衷方法。 7.4.4 回归测试 ​ 在集成测试过程中每当一个新模块结合进来时，程序就发生了变化，这些变化有可能使原来工作正常的功能出现问题。 回归测试：重新执行已经做过测试的某个子集，以保证上述这些变化没有带来非预期的副作用。 7.5 确认测试 也称为验收测试。 目标：验证软件的有效性。发现那些只有最终用户才能发现的错误。 验证：保证软件正确地实现了某个特定要求的一系列活动； 确认：为了保证软件确实满足了用户需求而进行的一系列活动。 软件的有效性： 如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的。 软件有效性的标准：需求分析阶段产生的软件需求规格说明书，它是确认测试的基础。 •Alpha测试 ​ 由一个用户在开发者的场所来进行的测试，软件在开发者对用户的指导下进行测试，开发者负责记录错误和使用中出现的问题。 •Beta测试 ​ 由软件的最终用户在一个或者多个用户场所来进行，开发者不在场，用户记录问题。 7.6 白盒测试技术 设计测试方案是测试阶段的关键技术问题。 测试方案： •包括测试目的（预定要测试的具体功能）， •应该输入的测试数据和预期的结果。 测试用例：由测试输入数据及与之对应的输出结果组成。 •测试用例设计的好坏直接决定了测试的效果和结果。因此在软件测试活动中最关键的步骤就是设计有效的测试用例。（因为不可能进行穷尽的测试） •测试用例可以针对黑盒测试设计用例，也可以针对白盒测试设计用例。 白盒测试技术：用白盒方法测试软件时设计测试数据的典型技术。 黑盒测试技术：用黑盒方法测试软件时设计测试数据的典型技术。 白盒测试的目的： • 保证一个模块中的所有独立路径至少被执行一次； •对所有的逻辑值均需要测试真、假两个分支； •在上下边界及可操作范围内运行所有循环； •检查内部数据结构以确保其有效性。 白盒测试的主要方法 • 逻辑驱动测试（逻辑覆盖） • 基本路径测试 ​ 主要用于软件验证。 用程序设计的控制结构导出测试用例。 7.6.1 逻辑覆盖 逻辑覆盖：是对一系列测试过程的总称。这组测试过程逐渐进行越来越完整的通路测试。 覆盖：测试数据执行源程序的过程。 覆盖源程序语句的详尽程度存在不同的覆盖标准： •语句覆盖 •判定覆盖 •条件覆盖 •判定/条件覆盖 •条件组合覆盖 例：图7.5所示的程序流程图描绘了一个被测模块的处理算法。 图7.5 被测试模块的流程图 \\1. 语句覆盖 语句覆盖的含义：选择足够多的测试数据，使被测程序中每个语句至少执行一次。 ​ 为了使每个语句都执行一次，程序的执行路径应该是sacbed。 ​ 需要输入下面的测试数据： ​ A=2，B=0，X=4（ X可以是任意实数) 语句覆盖缺点： •对程序的逻辑覆盖很少； •语句覆盖只关心判定表达式的值； •没有分别测试判定表达式中每个条件取不同值时的情况。 语句覆盖是很弱的逻辑覆盖标准。 \\2. 判定覆盖 又叫分支覆盖。 含义：不仅每个语句必须至少执行一次，而且每个判定的每个分支都至少执行一次。 需要输入下面的测试数据： ​ A=3，B=0，X=3（1） (路径是：sacbd) ​ A=2，B=1，X=1 (路径是：sabed) ​ 判定覆盖比语句覆盖强，但是对程序逻辑的覆盖程度仍然不高，只覆盖了程序全部路径的一半。 还差： sacbed，sabd \\3. 条件覆盖 含义:不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果。 测试数据使a点有下述各种结果： ​ A>1,A≤1,B=0,B≠0. 测试数据使b点有下述各种结果： ​ A=2,A≠2, X>1, X≤1. 需要输入下面的测试数据： ​ A=2，B=0，X=1 (路径是：sacbed) ​ A=1，B=1，X=2 (路径是：sabed ) (少bd分支) ​ 条件覆盖通常比判定覆盖强，它使判定表达式中每个条件都取到了两个不同的结果;不一定包含判定覆盖. ​ 判定覆盖只关心整个判定表达式的值。 含义:不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果。 测试数据使a点有下述各种结果： ​ A>1,A≤1,B=0,B≠0. 测试数据使b点有下述各种结果： ​ A=2,A≠2, X>1, X≤1. 另一组测试数据： ​ A=2，B=0，X=4 (路径是：sacbed) ​ A=1，B=1，X=1 (路径是：sabd ) 包含了判定覆盖。 \\4. 判定/条件覆盖 ​ 判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖。 因为：判定表达式中的每个条件都取到各种可能的结果，但不能保证每个判定表达式也都取到各种可能的结果。 提出了判定/条件覆盖。 判定/条件覆盖：一种能同时满足这两种覆盖标准的逻辑覆盖。 含义：选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。 有时判定/条件覆盖并不比条件覆盖更强。 测试数据使a点有下述各种结果： ​ A>1,A≤1,B=0,B≠0. 测试数据使b点有下述各种结果： ​ A=2,A≠2, X>1, X≤1. 测试数据： ​ A=2，B=0，X=4 (路径是：sacbed) ​ A=1，B=1，X=1 (路径是：sabd ) 也符合条件覆盖。 有时判定/条件覆盖并不一定比条件覆盖更强。 \\5. 条件组合覆盖 含义：使得每个判定表达式中条件的各种可能组合都至少出现一次。 共有8种组合： ​ A>1，B=0 , A>1，B≠0 ​ A≤1, B=0, A≤1, B≠0. ​ A= 2, X>1, A= 2 , X≤1 ​ A≠2, X>1, A≠2, X≤1 测试数据： ​ A=2，B=0，X=4 (路径是：sacbed) ​ A=2，B=1，X=1 (路径是：sabed ) ​ A=1，B=0，X=2 (路径是：sabed) ​ A=1，B=1，X=1 (路径是：sabd ) ​ 满足条件组合覆盖标准的测试数据，一定满足判定覆盖、条件覆盖和判定/条件覆盖标准。 是更强的逻辑覆盖标准。 但不一定能使程序中的每条路径都执行到。 ​ 如：sacbd \\6. 点覆盖 含义：选取足够多测试数据，使得程序执行路径至少经过流图的每个结点一次。 ​ 由于流图的每个结点与一条或多条语句相对应，显然，点覆盖标准和语句覆盖标准是相同的。 \\7. 边覆盖 含义：选取足够多测试数据，使得程序执行路径至少经过流图中每条边一次。 ​ 通常边覆盖和判定覆盖是一致的。 \\8. 路径覆盖 含义：选取足够多测试数据，使程序的每条可能路径都至少执行一次(如果程序图中有环，则要求每个环至少经过一次)。 图7.5程序有4条可执行通路: ​ sacbed,sacbd,sabed,sabd. 为做到路径覆盖，通常需要4组测试数据。 7.6.2 控制结构测试 1. 基本路径测试 •McCabe提出的一种白盒测试技术； •可以保证程序中的每条语句至少执行一次； •每个条件在执行时都将分别取真、假两种值。 　　使用该技术设计测试用例的步骤如下： 第一步，根据过程设计结果画出相应的流图。 流图 复合条件的流图 第二步，计算流图的环形复杂度。 ​ 前流图的环形复杂度为4。 第三步，确定线性独立路径的基本集合。 ​ 每一条新的路径都包含一条新边。 ​ 程序的环形复杂度决定了程序中独立路径的数量。 第四步，设计可强制执行基本集合中每条路径的测试用例。 ​ 一旦执行完所有测试用例，就可以确保程序中所有语句都至少被执行了一次，而且每个条件都分别取过true值和false值。 P156例：测试用PDL描述的求平均值过程。 •首先画出图7.6所示的流图。 PROCEDURE average; /* 这个过程计算不超过100个在规定值域内的有效数字的平均值；同时计算有效数字的总和及个数。*/ INTERFACE RETURNS average, total.input, total.valid; INTERFACE ACCEPTS value, minimum, maximum; TYPE value［1…100］ IS SCALAR ARRAY; TYPE average, total.input, total.valid; minimum,maximum, sum IS SCALAR; TYPE i IS INTEGER; 1: i=1; total.input=total.valid=0; sum=0; 2: DO WHILE value［i］ <> -999 3: AND total.input=minimum 6: AND value［i］0 11: THEN average=sum/total.valid; 12: ELSE average=-999; 13: ENDIF END average 图7.6 求平均值过程的流图 对于图7.6流图： •环形复杂度为6， •共有6条独立路径，P157 •设计执行每条路径的测试用例。P158 ​ 通常在设计测试用例时，识别出判定结点是很有必要的。本例中结点2、3、5、6和10是判定结点。 7.7 黑盒测试技术 • 黑盒测试着重测试软件功能。 • 黑盒测试不能取代白盒测试，是与白盒测试互补的测试方法，用于发现白盒测试不易发现的错误。 • 黑盒测试发现的错误类型： 　　①功能不正确或遗漏了功能； 　　②界面错误； 　　③数据结构错误或外部数据库访问错误； 　　 ④性能错误； 　　⑤初始化和终止错误。 白盒测试主要用于测试过程的早期， 黑盒测试主要用于测试过程的后期。 设计黑盒测试方案时，应该考虑下述问题： （1） 怎样测试功能的有效性？ （2） 哪些类型的输入可构成好测试用例？ （3） 系统是否对特定的输入值特别敏感？ （4） 怎样划定数据类的边界？ （5） 系统能够承受什么样的数据率和数据量？ （6） 数据的特定组合将对系统运行产生什么影响？ 应用黑盒测试技术，设计测试用例的标准： （1） 能够减少为达到合理测试所需要设计的测试用例的总数； （2） 能够告诉我们，是否存在某些类型的错误，而不是仅仅指出与特定测试相关的错误是否存在。 黑盒测试技术： •等价划分 •边界值分析 7.7.1 等价划分 等价划分：把程序的输入域划分成若干个数据类，据此导出测试用例。 ​ 一个理想的测试用例能独自发现一类错误。 ​ 穷尽的黑盒测试是不现实的。 ​ 等价划分法力图设计出能发现若干类程序错误的测试用例，从而减少必须设计的测试用例的数目。 •等价类：是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的。 •从等价类中选取一个数据进行测试，即可代表整个等价类中所有数据的测试结果，从而减少了测试时间和代价。 • 使用等价划分法设计测试方案，首先需要划分输入数据的等价类。 等价类划分规则： （1） 如果规定了输入值的范围，则可划分出一个有效的等价类(输入值在此范围内)，两个无效的等价类(输入值小于最小值或大于最大值)； ​ 100 （2） 如果规定了输入数据的个数，则可划分出一个有效的等价类和两个无效的等价类； （3） 如果规定了输入数据的一组值，而且程序对不同输入值做不同处理，则每个允许的输入值是一个有效的等价类，此外还有一个无效的等价类(任一个不允许的输入值)； ​ X∈{1，3，5，7} （4） 如果规定了输入数据必须遵循的规则，则可以划分出一个有效的等价类(符合规则)和若干个无效的等价类(从各种不同角度违反规则)； （5） 如果规定了输入数据为整型，则可以划分出正整数、零和负整数等3个有效类； （6）如果输入条件是一个布尔量，则可定义一个有效等价类和一个无效等价类。 ​ X为布尔量 实际情况千变万化，根本无法一一列出。 划分出等价类以后，根据等价类设计测试方案时主要使用下面两个步骤： (1) 设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止； (2) 设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止。 ​ 因为程序发现一类错误后就不再检查是否还有其他错误，因此，每个测试方案只覆盖一个无效的等价类。 下面用等价划分法设计一个简单程序的测试方案。 假设有一个把数字串转变成整数的函数。计算机字长16位，用二进制补码表示整数。这个函数是用Pascal语言编写的，它的说明如下：function strtoint (dstr:shortstr):integer;函数的参数类型是shortstr,它的说明是:type shortstr=array［1..6］ of char;被处理的数字串是右对齐的，如果数字串比6个字符短，则在它的左边补空格。如果数字串是负的，则负号和最高位数字紧相邻(负号在最高位数字左边一位)。 可以划分出如下等价类： • 有效输入的等价类有： (1) 1～6个数字字符组成的数字串(最高位数字不是零)； (2) 最高位数字是零的数字串； (3) 最高位数字左邻是负号的数字串； • 无效输入的等价类有： (4) 空字符串(全是空格)； (5) 左部填充的字符既不是零也不是空格； (6) 最高位数字右面由数字和空格混合组成； (7) 最高位数字右面由数字和其他字符混合组成； (8) 负号与最高位数字之间有空格； • 合法输出的等价类有： (9) 在计算机能表示的最小负整数和零之间的负整数； (10) 零； (11) 在零和计算机能表示的最大正整数之间的正整数； • 非法输出的等价类有 (12) 比计算机能表示的最小负整数还小的负整数； (13) 比计算机能表示的最大正整数还大的正整数。 ​ 因为所用计算机字长16位，能表示的最小负整数是-32 768，能表示的最大正整数是32 767。 7.7.2 边界值分析 ​ 人们从长期的测试工作经验得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。 • 针对各种边界情况设计测试用例，可以查出更多的错误。 • 对等价类方法的补充 比如，在做三角形计算时，要输入三角形的三个边长：A、B和C。 这三个数值应当满足： ​ A＞0、B＞0、C＞0、 ​ A＋B＞C、A＋C＞B、B＋C＞A， 但如果把 “＞”错写成 “≥”，那就不能构成三角形。问题恰出现在容易被疏忽的边界附近。 使用边界值分析方法设计测试方案： •首先应该确定边界情况。 •应该选取刚好等于、刚刚小于和刚刚大于边界值的数据作为测试数据，而不是选取每个等价类内的典型值或任意值作为测试数据。 ​ 100 ​ 通常设计测试方案时总是联合使用等价划分和边界值分析两种技术。 7.7.3 错误推测 • 经验表明，在一段程序中已经发现的错误数目往往和尚未发现的错误数成正比。 ​ 例如，在IBM OS/370操作系统中，用户发现的全部错误的47%只与该系统4%的模块有关。 ​ 因此，要着重测试那些已发现了较多错误的程序段。 • 等价划分法和边界值分析法都只孤立地考虑各个输入数据的测试功效，而没有考虑多个输入数据的组合效应，可能会遗漏了输入数据易于出错的组合情况。 • 选择输入组合的一个有效途径是利用判定表或判定树为工具，列出输入数据各种组合与程序应作的动作(及相应的输出结果)之间的对应关系，然后为判定表的每一列至少设计一个测试用例。 7.8 调试 •调试也称排错。 •调试与测试的关系主要体现在以下几个方面： (1)测试的目的是暴露错误；而调试的目的是发现错误，改正错误。 (2)测试是揭示设计人员的过失，通常应由非设计人员来承担；而调试是帮助设计人员纠正错误，可以由设计人员自己承担。 (3)测试发现错误后，立即进行调试并改正错误，然后进行再测试（回归测试）。 (4)调试用例与测试用例可以一致，也可以不一致。 7.8.1 调试过程 调试总是发生在测试之后，如图7.8所示。 ​ 调试过程从执行一个测试用例开始，评估测试结果，如果发现实际结果与预期结果不一致，表明在软件中存在隐藏的问题。调试过程试图找出问题的原因，以便改正错误。 调试过程总会有以下两种结果之一： ①找到了问题的原因并把问题改正和排除掉了； ②没找出问题的原因。此时，调试人员可以猜想一个原因，并设计测试用例附加测试，重复此过程直至找到原因并改正了错误。 图7.8 调试过程 7.8.2 调试途径 调试的目标：是寻找软件错误的原因并改正错误。一般说来，有下列途径可以采用： •试探法 •回溯法 •对分查找法 •归纳法 •演绎法 1.试探法 分析错误征兆，猜测发生错误的大概位置，然后利用有关的调试技术进一步获得错误信息。这种策略往往是缓慢而低效的。 \\2. 回溯法 •首先检查错误征兆，确定最先发现错误的位置，然后人工沿程序的控制流往回追踪源程序代码，直到找出错误根源或确定故障范围为止。 •回溯法对于小程序而言是一种比较好的调试策略。但是对于大程序，其回溯的路径数目会变得很大，以至使彻底回溯成为不可能。 •回溯法的另一种形式是正向追踪，即使用插入打印语句的方法检查一系列中间结果，以确定最先出现错误的地方。 3.对分查找法 在程序的中点附近输入某些变量的正确值(如利用赋值语句或输入语句)，然后观察程序的输出。若输出结果正确，则说明错误出现在程序的前半部分；否则，说明程序的后半部分有错。对于程序中有错的那部分再重复使用这个方法，直到把错误范围缩小到容易诊断的程度为止。 4.归纳法 归纳法：是从个别推断全体，即从线索(错误征兆)出发，通过分析这些线索之间的关系而找出故障。这种方法主要有以下四个步骤： ①收集已有的使程序出错与不出错的所有数据。 ②整理这些数据，以便发现规律或矛盾。 ③提出关于故障的若干假设。 ④证明假设的合理性，根据假设排除故障 5.演绎法 •演绎法是从一般原理或前提出发，经过删除和精化的过程，最后推导出结论。 •用演绎法排错时，首先要列出所有可能造成出错的原因和假设，然后逐个排除，最后证明剩下的原因确实是错误的根源。演绎法排错主要有以下四个步骤： ​ ①设想所有可能产生错误的原因。 ​ ②利用已有的数据排除不正确的假设。 ​ ③精化剩下的假设。 ​ ④证明假设的合理性，根据假设排除故障。 7.9 软件可靠性 7.9.1 基本概念 软件可靠性的定义 软件可靠性：是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。 ​ 随着运行时间的增加，运行时出现程序故障的概率也将增加，可靠性随着给定的时间间隔的加大而减少。 按照IEEE的规定 错误：是由开发人员造成的软件差错（bug）。 故障：是由错误引起的软件的不正确行为。 \\2. 软件的可用性 软件可用性：是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。 可靠性和可用性之间的主要差别是： • 可靠性意味着在0到t这段时间间隔内系统没有失效， •可用性只意味着在时刻t，系统是正常运行的。 ​ 因此，如果在时刻t系统是可用的，则有下述种种可能： ​ 在0到t这段时间内，系统一直没失效(可靠)； ​ 在这段时间内失效了一次，但是又修复了； ​ 在这段时间内失效了两次修复了两次；…… 7.10 小结 实现包括编码和测试两个阶段。 ​ 编码是在对软件进行了总体设计和详细设计之后进行的，它只不过是把软件设计的结果翻译成用某种程序设计语言书写的程序，因此，程序的质量基本上取决于设计的质量。 ​ 但是，编码使用的语言，特别是写程序的风格，也对程序质量有相当大的影响。 ​ 软件测试仍然是保证软件可靠性的主要手段。 ​ 测试阶段的根本任务是发现并改正软件中的错误。 ​ 软件测试是软件开发过程中最艰巨最繁重的任务，应该分阶段地进行，分为单元测试、集成测试和验收测试3个基本阶段。 ​ 设计测试方案是测试阶段的关键技术问题，基本目标是选用最少量的高效测试数据，做到尽可能完善的测试，从而尽可能多地发现软件中的问题。 ​ 两种测试途径：计算机进行测试，人工进行测试(例如，代码审查)。两种途径各有优缺点，互相补充，缺一不可。 ​ 白盒测试和黑盒测试是软件测试的两类基本方法，这两类方法各有所长，相互补充。 ​ 在测试过程的早期阶段主要使用白盒方法，而在测试过程的后期阶段主要使用黑盒方法。 ​ 设计白盒测试方案的技术主要有，逻辑覆盖和控制结构测试； ​ 设计黑盒测试方案的技术主要有，等价划分、边界值分析和错误推测。 ​ 在测试过程中发现的软件错误必须及时改正，这就是调试的任务。 ​ 为了改正错误，首先必须确定错误的准确位置，如需要修正原来的设计，必须通盘考虑统筹兼顾，而不能“头疼医头、脚疼医脚”，应该尽量避免在调试过程中引进新错误。 ​ 测试和调试是软件测试阶段中的两个关系非常密切的过程，它们往往交替进行。 "},"page/1019.html":{"url":"page/1019.html","title":"维护","keywords":"","body":"维护 第8章 维护 基本任务： ​ 是保证软件在一个相当长的时期能够正常运行。 ​ 软件维护需要的工作量很大，60%以上的人力用于维护已有的软件，随着投入使用的软件数量增多和使用寿命延长，这个百分比还在持续上升。最终导致软件开发组织没有余力开发新的软件。 软件工程的目的： ​ 要提高软件的可维护性，减少软件维护所需要的工作量，降低软件系统的总成本。 8.1 软件维护的定义 软件维护： ​ 在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。 ​ 可以通过以下4项活动，具体地定义软件维护。 •四种维护类型： 改正性维护 适应性维护 完善性维护 预防性维护 1.改正性维护 ​ 在软件交付使用后，因开发时测试的不彻底、不完全，必然会有部分隐藏的错误遗留到运行阶段。 ​ 这些隐藏下来的错误在某些特定的使用环境下就会暴露出来。 ​ 为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应当进行的诊断和改正错误的过程。 2.适应性维护 在使用过程中，外部环境、数据环境可能发生变化。 外部环境（新的硬、软件配置） 数据环境（数据库、数据格式、数据输入/输出方式、数据存储介质） 适应性维护：为使软件适应这种变化，而去修改软件的过程。 3.完善性维护 •在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。 •完善性维护： ​ 为了满足上述要求，需要修改或再开发软件而进行的完善性的维护活动。以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。 •完善性维护不一定是救火式的紧急维修，可以是有计划、有预谋的一种再开发活动。 4.预防性维护 •预防性维护： 为了提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础而修改软件的维护活动。 •预防性维护的定义： 采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试的过程。 国外的统计数字表明： 完善性维护占全部维护活动的50%～66%， 改正性维护占17%～21%， 适应性维护占18%～25%， 其他维护活动只占4%左右。 完善性维护占了几乎一半的工作量。 可见： 大部分维护工作是改变和加强软件，不是纠错。 8.2 软件维护的特点 8.2.1 结构化维护与非结构化维护差别巨大 \\1. 非结构化维护 ​ 如果软件配置的惟一成分是程序代码， •那么维护活动从艰苦地评价程序代码开始。 •没有设计文档及测试文档。 ​ 非结构化维护需要付出很大代价，这种维护方式是没有使用良好的方法学开发出来的软件的必然结果。 \\2. 结构化维护 ​ 如果有一个完整的软件配置存在， •那么维护工作从评价设计文档开始； •估量要求的改动将带来的影响，并且计划实施途径。 •然后修改设计并且对所做的修改进行仔细复查。 •编写相应的源程序代码； •使用在测试说明书中包含的信息进行回归测试； •把修改后的软件再次交付使用。 8.2.2 维护的代价高昂 •软件维护活动所花费的工作占整个生存期工作量的70%以上。 在漫长的软件运行过程中需要不断对软件进行修改，以改正新发现的错误、适应新的环境和用户新的要求，这些修改需要花费很多精力和时间，而且有时会引入新的错误。 •维护费用是软件维护的最明显的代价，还有一些无形的代价。 无形的代价还有： •可用的资源必须供维护任务使用，以致耽误甚至丧失了开发的良机。 •改错或修改的不及时，引起的用户不满； •由于维护时的改动，在软件中引入了潜伏的错误，从而降低了软件的质量； •把软件工程师调去从事维护工作，在开发过程中造成的混乱。 •生产率的大幅度下降，尤其在维护旧程序时常常遇到。 维护工作量的一个模型：M = P + K × exp(c-d) 其中： • M是维护用的总工作量， • P是生产性工作量（分析等必要的过程） ， • K是经验常数， • c是复杂程度(非结构化设计和缺少文档都会增加软件的复杂程度)， • d是维护人员对软件的熟悉程度。 模型表明： ​ 如果软件的开发途径不好(没有使用软件工程方法学)，而且原来的开发人员不能参加维护工作，那么维护工作量和费用将指数地增加。 8.2.3 维护的问题很多 ​ 存在于没采用软件工程思想开发出来的软件中： （1） 仅有程序代码没有说明文档；。 （2） 缺少容易理解的并且和程序代码完全一致的文档； （3） 不能指望由开发人员给我们仔细说明软件。由于维护阶段持续的时间很长，写程序的人已经不在了。 （4） 绝大多数软件在设计时没有考虑将来的修改。没有使用模块独立的原理去的设计，使修改软件既困难又容易发生差错。 所以，应采用软件工程思想来开发软件 8.3 软件维护过程 • 先建立一个维护组织； • 确定报告和评价的过程； • 为每个维护要求规定一个标准化的事件序列； • 建立一个适用于维护活动的记录保管过程； • 规定复审标准。 \\1. 维护组织 对于每个维护要求： •通过维护管理员转交给相应的系统管理员去评价。 ​ 系统管理员对维护任务做出评价之后， •由变化授权人决定应该进行的活动。 图8.1描绘了上述组织方式。 目的：在维护活动开始之前就明确维护责任。 图8.1 维护组织 \\2. 维护报告 • 应该用标准化的格式表达所有软件维护要求。 • 软件维护人员通常给用户提供空白的维护要求表——有时称为软件问题报告表。 ​ 这个表格由要求维护活动的用户填写。 ​ 由维护管理员和系统管理员评价用户提交的维护要求表。 \\3. 维护的事件流 图8.2描绘了由一项维护要求而引出的一串事件。 •首先应该确定要求进行的维护的类型。 •改正性维护要求： ​ 估量错误的严重程度； ​ 是一个严重的错误，在系统管理员的指导下分派人员，立即开始问题分析过程； ​ 错误并不严重，与其他的软件开发任务一起统筹安排。 •适应性维护和完善性维护要求： ​ 应该确定每个维护要求的优先次序； ​ 安排要求的工作时间； ​ 如果优先次序非常高，可能立即开始维护工作。 软件维护工作流程 \\4. 保存维护记录 ①程序标识；②源语句数； ③机器指令条数； ④使用的程序设计语言；⑤程序安装的日期； ⑥自从安装以来程序运行的次数； ⑦自从安装以来程序失效的次数； ⑧程序变动的层次和标识； ⑨因程序变动而增加的源语句数； ​ 因程序变动而删除的源语句数； 每个改动耗费的人时数； 程序改动的日期； 软件工程师的名字； 维护要求表的标识； 维护类型； 维护开始和完成的日期； 累计用于维护的人时数； 与完成的维护相联系的纯效益。 \\5. 评价维护活动 从下述7个方面度量维护工作： (1) 每次程序运行平均失效的次数； (2) 用于每一类维护活动的总人时数； (3) 平均每个程序、每种语言、每种维护类型所做的程序变动数； (4) 维护过程中增加或删除一个源语句平均花费的人时数； (5) 维护每种语言平均花费的人时数； (6) 一张维护要求表的平均周转时间； (7) 不同维护类型所占的百分比。 ​ 由此做出关于开发技术、语言选择、维护工作量规划、资源分配等方面的决定。 8.4 软件的可维护性 ​ 定义： 维护人员理解、改正、改动或改进这个软件的难易程度。 ​ 提高可维护性是软件开发阶段各个时期的关键目标。 8.4.1 决定软件可维护性的因素 维护：就是在软件交付使用后进行的修改。 •修改之前必须理解待修改的对象， •修改之后应该进行必要的测试，以保证所做的修改是正确的。 •如果是改正性维护，还必须预先进行调试以确定错误的具体位置。 因此，决定软件可维护性的因素主要有下述5个： 可理解性，可测试性，可修改性，可移植性， 可重用性 \\1. 可理解性 •可理解性：外来读者理解软件的结构、功能、接口和内部处理过程的难易程度。 •影响因素： ​ 模块化（模块结构良好，高内聚，松耦合）、详细的设计文档、结构化设计、程序内部的文档和良好的高级程序设计语言等等。 \\2. 可测试性 •可测试性：论证程序正确性的容易程度。 •模块的环形复杂度可度量它的可测试性。 ​ 模块的环形复杂度越大，可执行的路径就越多，全面测试它的难度就越高。 •影响因素： 良好的文档，软件结构、测试工具和调试工具，以前测试时设计的测试过程。 \\3. 可修改性 可修改性：软件容易修改的程度。 影响因素：耦合、内聚、信息隐藏、局部化、控制域与作用域的关系等等。 \\4. 可移植性 可移植性：把程序从一种计算环境（硬件配置和操作系统）转移到另一种计算环境的难易程度。 对策： ​ 把与硬件、操作系统及其他外部设备有关的程序代码集中放到特定的程序模块中，受环境变化影响的仅有少数程序模块，从而降低修改的难度。 \\5. 可重用性 重用（reuse）：同一事物不做修改或稍加改动就在不同环境中多次重复使用。 使用可重用的构件来开发软件，可以提高软件的可维护性： • 软件中使用的可重用构件越多，软件的可靠性越高，改正性维护需求越少。 • 很容易修改可重用的软件构件使之再次应用在新环境中，因此，软件中使用的可重用构件越多，适应性和完善性维护也就越容易。 8.4.2 文档 文档：是影响软件可维护性的决定因素。 ​ 大型软件系统在长期的使用过程中必然会经受多次修改，所以文档比程序代码更重要。 文档分类： •系统文档：描述系统设计、实现和测试等一系列和系统实现有关的文档。 •用户文档：描述系统功能和使用方法，并不关心这些功能怎样实现。包括： 功能描述；安装文档；使用手册；参考手册；操作员指南。 用户文档应包括的5方面内容： (1) 功能描述，说明系统能做什么； (2) 安装文档，说明怎样安装这个系统以及怎样使系统适应特定的硬件配置； (3) 使用手册，通过丰富例子说明怎样使用常用的系统功能，及用户操作错误时怎样恢复和重新启动； (4) 参考手册，详尽描述用户可以使用的所有系统设施及使用方法，解释系统可能产生的各种出错信息的含义； (5) 操作员指南(如果需要的话)，说明操作员应该如何处理使用中出现的各种情况。 8.4.3 可维护性复审 •在软件工程过程的每一个阶段都应该努力提高软件的可维护性，在每个阶段结束前的技术审查和管理复审中，应该着重对可维护性进行复审。 ​ 从需求分析到设计与编码等各阶段。 •在完成了每项维护工作之后，都应该对软件维护本身进行仔细认真的复审。 •维护应该针对整个软件配置，不应该只修改源程序代码。 8.5 预防性维护 产生背景: 存在这样一些程序： •体系结构和数据结构都很差， •文档不全甚至完全没有文档， •对曾经做过的修改也没有完整的记录。 •但仍然在为用户服务。 怎样满足用户对这类程序的维护要求呢？ 有以下几种做法可供选择： （1） 反复多次地做修改程序的尝试，与不可见的设计及源代码“顽强战斗”，以实现所要求的修改； ​ 该做法很盲目，通常人们采用后3种做法。 （2） 通过仔细分析程序尽可能多地掌握程序的内部工作细节，以便更有效地修改它； （3） 在深入理解原有设计的基础上，用软件工程方法重新设计、重新编码和测试那些需要变更的软件部分； （4） 以软件工程方法学为指导，对程序全部重新设计、重新编码和测试，为此可以使用CASE工具（逆向工程和再工程工具）来帮助理解原有的设计。 •由Miller提出的。 •定义：“把今天的方法学应用到昨天的系统上，以支持明天的需求。” 依据： （1） 维护一行源代码的代价可能是最初开发该行源代码代价的14~40倍； （2） 重新设计软件体系结构（程序及数据结构）时使用了现代设计概念，它对将来的维护可能有很大的帮助； 依据： （3） 由于现有的程序版本可作为软件原型使用，开发生产率可大大高于平均水平； （4） 用户具有较多使用该软件的经验，因此，能够很容易地搞清新的变更需求和变更的范围； （5） 利用逆向工程和再工程的工具，可以使一部分工作自动化； （6） 在完成预防性维护的过程中可以建立起完整的软件配置。 8.6 软件再工程过程 过程模型如图8.3所示，定义了6类活动。 ​ 再工程范型是一个循环模型。每个活动都可能被重复，过程可以在完成任意一个活动之后终止。 图8.3 软件再工程过程模型 下面简要地介绍该模型所定义的6类活动。 \\1. 库存目录分析 •每个软件组织都应该保存其拥有的所有应用系统的库存目录。 •该目录包含关于每个应用系统的基本信息（例如，应用系统的名字，最初构建它的日期，已做过的实质性修改次数，过去18个月报告的错误，用户数量，安装它的机器数量，它的复杂程度，文档质量，整体可维护性等级，预期寿命，在未来36个月内的预期修改次数，业务重要程度等）。 •库存目录分析：分析哪些需要进行再工程过程。 有3类程序： （1） 预定将使用多年的程序； （2） 当前正在成功地使用着的程序； （3） 在最近的将来可能要做重大修改或增强的程序。 \\2. 文档重构 老程序固有的特点是缺乏文档。处理方法： （1） 如果一个程序是相对稳定的，正在走向终点，保持现状，不建文档。 （2） 只针对系统中当前正在修改的那些部分建立完整文档。随着时间流逝，将得到一组有用的和相关的文档。 （3） 如果某应用系统是完成业务工作的关键，而且必须重构全部文档，也设法把文档工作减少到必需的最小量。 \\3. 逆向工程 •软件的逆向工程：是分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程； •逆向工程是一个恢复设计结果的过程； •逆向工程工具从现存的程序代码中抽取有关数据、体系结构和处理过程的设计信息。 \\4. 代码重构 •代码重构是最常见的再工程活动。 •某些老程序具有比较完整、合理的体系结构，但是，个体模块的编码方式却是难于理解、测试和维护的，可进行代码重构。 •重构过程：分析源代码→标注需重构部分→重构→复审、测试→更新文档。 •重构并不修改整体的程序体系结构，它仅关注个体模块的设计细节以及在模块中定义的局部数据结构。 •如果重构扩展到模块边界之外，并涉及软件体系结构，则重构变成了正向工程。 \\5. 数据重构 •对数据体系结构差的程序很难进行适应性修改和增强； •数据体系结构比源代码本身对程序的长期生存力有更大影响； •由于数据体系结构对程序体系结构及算法有很大影响，对数据的修改必然会导致体系结构或代码层的改变。 •当数据结构较差时，应该对数据进行再工程。 \\6. 正向工程 •正向工程也称为革新或改造； •不仅从现有程序中恢复设计信息，而且使用该信息去改变或重构现有系统，以提高其整体质量。 •被再工程的软件不仅重新实现现有系统的功能，而且加入了新功能和提高了整体性能。 8.7 小结 维护是软件生命周期的最后一个阶段，也是持续时间最长代价最大的一个阶段。 软件维护通常包括4类活动： 为了纠正在使用过程中暴露出来的错误而进行的改正性维护； 为了适应外部环境的变化而进行的适应性维护； 为了改进原有的软件而进行的完善性维护； 以及为了改进将来的可维护性和可靠性而进行的预防性维护。 软件的可理解性、可测试性、可修改性、可移植性和可重用性，是决定软件可维护性的基本因素。 软件重用技术能从根本上提高软件可维护性。 软件生命周期每个阶段的工作都和软件可维护性有密切关系。因此，在软件生命周期的每个阶段都必须充分考虑维护问题，并且为软件维护预做准备。 文档是影响软件可维护性的决定因素，甚至比程序代码更重要。文档必须和程序代码同时维护。 虽然由于维护资源有限，目前预防性维护在全部维护活动中仅占很小比例，但在条件具备时应该主动地进行预防性维护。 预防性维护实质上是软件再工程。 "},"page/1020.html":{"url":"page/1020.html","title":"软件项目管理","keywords":"","body":"软件项目管理 第13章 软件项目管理 与开发过程并行，一个是技术路线，一个是管理路线 在经历了若干个大型软件工程项目的失败之后，人们才逐渐认识到软件项目管理的重要性和特殊性。事实上，这些项目的失败并不是由于从事软件开发工作的软件工程师无能，正相反，他们之中的绝大多数是当时杰出的技术专家。这些工程项目的失败主要是因为管理不善。 所谓管理就是通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。 软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命周期之中。 软件项目管理过程从一组项目计划活动开始，而制定计划的基础是工作量估算和完成期限估算。为了估算项目的工作量和完成期限，首先需要估算软件的规模。 13.1 估算软件规模 13.1.1 代码行技术 代码行技术是比较简单的定量估算软件规模的方法。这种方法依据以往开发类似产品的经验和历史数据，估计实现一个功能所需要的源程序行数。当有以往开发类似产品的历史数据可供参考时，用这种方法估计出的数值还是比较准确的。把实现每个功能所需要的源程序行数累加起来，就可得到实现整个软件所需要的源程序行数。 为了使得对程序规模的估计值更接近实际值，可以由多名有经验的软件工程师分别做出估计。每个人都估计程序的最小规模(a)、最大规模(b)和最可能的规模(m)，分别算出这3种规模的平均值,和之后，再用下式计算程序规模的估计值： L= (13.1) 用代码行技术估算软件规模时，当程序较小时常用的单位是代码行数（LOC），当程序较大时常用的单位是千行代码数（KLOC）。 代码行技术的主要优点是，代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。代码行技术的缺点是： 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模似乎不太合理；用不同语言实现同一个软件所需要的代码行数并不相同；这种方法不适用于非过程语言。为了克服代码行技术的缺点，人们又提出了功能点技术。 13.1.2 功能点技术 功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。这种方法用功能点（FP）为单位度量软件规模。 \\1. 信息域特性 功能点技术定义了信息域的5个特性，分别是输入项数(Inp)、输出项数(Out)、查询数(Inq)、主文件数(Maf)和外部接口数(Inf)。下面讲述这5个特性的含义。 （1） 输入项数： 用户向软件输入的项数，这些输入给软件提供面向应用的数据。输入不同于查询，后者单独计数，不计入输入项数中。 （2） 输出项数： 软件向用户输出的项数，它们向用户提供面向应用的信息，例如，报表和出错信息等。报表内的数据项不单独计数。 （3） 查询数： 查询即是一次联机输入，它导致软件以联机输出方式产生某种即时响应。 （4） 主文件数： 逻辑主文件（即数据的一个逻辑组合，它可能是大型数据库的一部分或是一个独立的文件）的数目。 （5） 外部接口数： 机器可读的全部接口（例如，磁盘或磁带上的数据文件）的数量，用这些接口把信息传送给另一个系统。 \\2. 估算功能点的步骤 用下述3个步骤，可估算出一个软件的功能点数（即软件规模）。 （1） 计算未调整的功能点数UFP 首先，把产品信息域的每个特性(即Inp、Out、Inq、Maf和Inf)都分类为简单级、平均级或复杂级，并根据其等级为每个特性分配一个功能点数（例如，一个简单级的输入项分配3个功能点，一个平均级的输入项分配4个功能点，而一个复杂级的输入项分配6个功能点）。 然后，用下式计算未调整的功能点数UFP： UFP=a1×Inp+a2×Out+a3×Inq+a4×Maf+a5×Inf 其中，ai(1≤i≤5)是信息域特性系数，其值由相应特性的复杂级别决定，如表13.1（见书297页）所示。 (2) 计算技术复杂性因子TCF 这一步骤度量14种技术因素对软件规模的影响程度。这些因素包括高处理率、性能标准（例如，响应时间）、联机更新等，在表13.2（见书297页）中列出了全部技术因素，并用Fi(1≤i≤14)代表这些因素。根据软件的特点，为每个因素分配一个从0（不存在或对软件规模无影响）到5（有很大影响）的值。然后，用下式计算技术因素对软件规模的综合影响程度DI： DI= 技术复杂性因子TCF由下式计算： TCF=0.65+0.01×DI 因为DI的值在0~70之间，所以TCF的值在0.65~1.35之间。 （3） 计算功能点数FP 用下式计算功能点数FP： FP=UFP×TCF 功能点数与所用的编程语言无关，看起来功能点技术比代码行技术更合理一些。但是，在判断信息域特性复杂级别和技术因素的影响程度时，存在着相当大的主观因素。 13.2 工作量估算 软件估算模型使用由经验导出的公式来预测软件开发工作量，工作量是软件规模（KLOC或FP）的函数，工作量的单位通常是人月（pm)。 支持大多数估算模型的经验数据，都是从有限个项目的样本集中总结出来的，因此，没有一个估算模型可以适用于所有类型的软件和开发环境。 13.2.1 静态单变量模型 这类模型的总体结构形式如下： E=A+B×(ev)C 其中，A、B和C是由经验数据导出的常数，E是以人月为单位的工作量，ev是估算变量（KLOC或FP）。下面给出几个典型的静态单变量模型。 \\1. 面向KLOC的估算模型 (1) Walston_Felix模型 E=5.2×(KLOC)0.91 (2) Bailey_Basili模型 E=5.5+0.73×(KLOC)1.16 (3) Boehm简单模型 E=3.2×(KLOC)1.05 (4) Doty模型（在KLOC>9时适用） E=5.288×(KLOC)1.047 \\2. 面向FP的估算模型 (1) Albrecht & Gaffney模型 E=-13.39+0.0545FP (2) Maston,Barnett和Mellichamp模型 E=585.7+15.12FP 从上面列出的模型可以看出，对于相同的KLOC或FP值，用不同模型估算将得出不同的结果。主要原因是，这些模型多数都是仅根据若干应用领域中有限个项目的经验数据推导出来的，适用范围有限。因此，必须根据当前项目的特点选择适用的估算模型，并且根据需要适当地调整（例如，修改模型常数）估算模型。 13.2.2 动态多变量模型 动态多变量模型也称为软件方程式，它是根据从4000多个当代软件项目中收集的生产率数据推导出来的。该模型把工作量看作是软件规模和开发时间这两个变量的函数。动态多变量估算模型的形式如下： E=(LOC×B0.333/P)3×(1/t)4 (13.2) 其中， E是以人月或人年为单位的工作量； t是以月或年为单位的项目持续时间； B是特殊技术因子，它随着对测试、质量保证、文档及管理技术的需求的增加而缓慢增加，对于较小的程序（KLOC=5~15），B=0.16,对于超过70 KLOC的程序，B=0.39; P是生产率参数，它反映了下述因素对工作量的影响： 　　总体过程成熟度及管理水平； 　　使用良好的软件工程实践的程度； 　　使用的程序设计语言的级别； 　　软件环境的状态； 　　软件项目组的技术及经验； 应用系统的复杂程度。 开发实时嵌入式软件时，P的典型值为2000；开发电信系统和系统软件时，P=10000；对于商业应用系统来说，P=28000。可以从历史数据导出适用于当前项目的生产率参数值。 从（13.2）式可以看出，开发同一个软件（即LOC固定）的时候，如果把项目持续时间延长一些，则可降低完成项目所需的工作量。 13.2.3 COCOMO2模型 COCOMO是构造性成本模型（constructive cost model)的英文缩写。1981年Boehm在《软件工程经济学》中首次提出了COCOMO模型，本书第三版曾对此模型作了介绍。1997年Boehm等人提出的COCOMO2模型，是原始的COCOMO模型的修订版，它反映了十多年来在成本估计方面所积累的经验。 COCOMO2给出了3个层次的软件开发工作量估算模型，这3个层次的模型在估算工作量时，对软件细节考虑的详尽程度逐级增加。这些模型既可以用于不同类型的项目，也可以用于同一个项目的不同开发阶段。这3个层次的估算模型分别是： （1） 应用系统组成模型。这个模型主要用于估算构建原型的工作量，模型名字暗示在构建原型时大量使用已有的构件。 （2） 早期设计模型。这个模型适用于体系结构设计阶段。 （3） 后体系结构模型。这个模型适用于完成体系结构设计之后的软件开发阶段。 下面以后体系结构模型为例，介绍COCOMO2模型。该模型把软件开发工作量表示成代码行数（KLOC）的非线性函数： E= (13.3) 其中， E是开发工作量（以人月为单位）， a是模型系数， KLOC是估计的源代码行数（以千行为单位）， b是模型指数， fi(i=1~17)是成本因素。 每个成本因素都根据它的重要程度和对工作量影响大小被赋予一定数值（称为工作量系数）。这些成本因素对任何一个项目的开发工作量都有影响，即使不使用COCOMO2模型估算工作量，也应该重视这些因素。Boehm把成本因素划分成产品因素、平台因素、人员因素和项目因素等4类。 表13.3（见书300页）列出了COCOMO2模型使用的成本因素及与之相联系的工作量系数。与原始的COCOMO模型相比，COCOMO2模型使用的成本因素有下述变化，这些变化反映了在过去十几年中软件行业取得的巨大进步。 （1） 新增加了4个成本因素，它们分别是要求的可重用性、需要的文档量、人员连续性（即人员稳定程度）和多地点开发。这个变化表明，这些因素对开发成本的影响日益增加。 （2） 略去了原始模型中的2个成本因素（计算机切换时间和使用现代程序设计实践）。现在，开发人员普遍使用工作站开发软件，批处理的切换时间已经不再是问题。而“现代程序设计实践”已经发展成内容更广泛的“成熟的软件工程实践”的概念，并且在COCOMO2工作量方程的指数b中考虑了这个因素的影响。 （3） 某些成本因素（分析员能力、平台经验、语言和工具经验）对生产率的影响（即工作量系数最大值与最小值的比率）增加了，另一些成本因素（程序员能力）的影响减小了。 为了确定工作量方程中模型指数b的值，原始的COCOMO模型把软件开发项目划分成组织式、半独立式和嵌入式这样3种类型，并指定每种项目类型所对应的b值（分别是1.05，1.12和1.20）。COCOMO2采用了更加精细得多的b分级模型，这个模型使用5个分级因素Wi(1≤i≤5),其中每个因素都划分成从甚低（Wi=5)到特高（Wi=0)的6个级别，然后用下式计算b的数值： b= (13.4) 因此，b的取值范围为1.01~1.26。显然，这种分级模式比原始COCOMO模型的分级模式更精细、更灵活。 COCOMO2使用的5个分级因素如下所述： （1） 项目先例性。这个分级因素指出，对于开发组织来说该项目的新奇程度。诸如开发类似系统的经验，需要创新体系结构和算法，以及需要并行开发硬件和软件等因素的影响，都体现在这个分级因素中。 （2） 开发灵活性。这个分级因素反映出，为了实现预先确定的外部接口需求及为了及早开发出产品而需要增加的工作量。 （3） 风险排除度。这个分级因素反映了重大风险已被消除的比例。在多数情况下，这个比例和指定了重要模块接口（即选定了体系结构）的比例密切相关。 （4） 项目组凝聚力。这个分级因素表明了开发人员相互协作时可能存在的困难。这个因素反映了开发人员在目标和文化背景等方面相一致的程度，以及开发人员组成一个小组工作的经验。 （5） 过程成熟度。这个分级因素反映了按照能力成熟度模型（见13.7节）度量出的项目组织的过程成熟度。 在原始的COCOMO模型中，仅粗略地考虑了前两个分级因素对指数b之值的影响。 工作量方程中模型系数a的典型值为3.0，在实际工作中应该根据历史经验数据确定一个适合本组织当前开发的项目类型的数值。 13.3 进度计划 不论从事哪种技术性项目，实际情况都是，在实现一个大目标之前往往必须完成数以百计的小任务（也称为作业）。这些任务中有一些是处于“关键路径”（见13.3.5节）之外的，其完成时间如果没有严重拖后，就不会影响整个项目的完成时间；其他任务则处于关键路径之中，如果这些“关键任务”的进度拖后，则整个项目的完成日期就会拖后，管理人员应该高度关注关键任务的进展情况。 没有一个普遍适用于所有软件项目的任务集合，因此，一个有效的软件过程应该定义一个适用于当前项目的任务集合。一个任务集合包括一组软件工程工作任务、里程碑和可交付的产品。为一个项目所定义的任务集合，必须包括为获得高质量的软件产品而应该完成的所有任务，但是同时又不能让项目组承担不必要的工作。 项目管理者的目标是定义全部项目任务，识别出关键任务，跟踪关键任务的进展状况，以保证能及时发现拖延进度的情况。为达到上述目标，管理者必须制定一个足够详细的进度表，以便监督项目进度并控制整个项目。 软件项目的进度安排是这样一种活动，它通过把工作量分配给特定的软件工程任务并规定完成各项任务的起止日期，从而将估算出的项目工作量分布于计划好的项目持续期内。进度计划将随着时间的流逝而不断演化。在项目计划的早期，首先制定一个宏观的进度安排表，标识出主要的软件工程活动和这些活动影响到的产品功能。随着项目的进展，把宏观进度表中的每个条目都精化成一个详细进度表，从而标识出完成一个活动所必须实现的一组特定任务，并安排好了实现这些任务的进度。 13.3.1 估算开发时间 估算出完成给定项目所需的总工作量之后，接下来需要回答的问题就是： 用多长时间才能完成该项目的开发工作？对于一个估计工作量为20人月的项目，可能想出下列几种进度表： 1个人用20个月完成该项目； 4个人用5个月完成该项目； 20个人用1个月完成该项目。 但是，这些进度表并不现实，实际上软件开发时间与从事开发工作的人数之间并不是简单的反比关系。 通常，成本估算模型也同时提供了估算开发时间T的方程。与工作量方程不同，各种模型估算开发时间的方程很相似，例如： (1) Walston_Felix模型 T=2.5E0.35 (2) 原始的COCOMO模型 T=2.5E0.38 (3) COCOMO2模型 T=3.0E0.33+0.2×(b-1.01) (4) Putnam模型 T=2.4E1/3 其中， E是开发工作量（以人月为单位）， T是开发时间（以月为单位）。 用上列方程计算出的T值，代表正常情况下的开发时间。客户往往希望缩短软件开发时间，显然，为了缩短开发时间应该增加从事开发工作的人数。但是，经验告诉我们，随着开发小组规模扩大，个人生产率将下降，以致开发时间与从事开发工作的人数并不成反比关系。出现这种现象主要有下述两个原因： 当小组变得更大时，每个人需要用更多时间与组内其他成员讨论问题、协调工作，因此增加了通信开销。 如果在开发过程中增加小组人员，则最初一段时间内项目组总生产率不仅不会提高反而会下降。这是因为新成员在开始时不仅不是生产力，而且在他们学习期间还需要花费小组其他成员的时间。 综合上述两个原因，存在被称为Brooks规律的下述现象： 向一个已经延期的项目增加人力，只会使得它更加延期。 下面让我们研究项目组规模与项目组总生产率的关系。 项目组成员之间的通信路径数，由项目组人数和项目组结构决定。如果项目组共有P名组员，每个组员必须与所有其他组员通信以协调开发活动，则通信路径数为P(P-1)/2。如果每个组员只需与另外一个组员通信，则通信路径数为P-1。通信路径数少于P-1是不合理的，因为那将导致出现与任何人都没有联系的组员。 因此，通信路径数大约在P~P2/2的范围内变化。也就是说，在一个层次结构的项目组中，通信路径数为Pα，其中1 对于某一个组员来说，他与其他组员通信的路径数在1~（P-1）的范围内变化。如果不与任何人通信时个人生产率为L，而且每条通信路径导致生产率减少l，则组员个人平均生产率为 Lr=L-l(P-1)r (13.5) 其中，r是对通信路径数的度量，00)。 对于一个规模为P的项目组，从（13.5）式导出项目组的总生产率为 Ltot=P(L-l(P-1)r) (13.6) 对于给定的一组L，l和r的值，总生产率Ltot是项目组规模P的函数。随着P值增加，Ltot将从0增大到某个最大值，然后再下降。因此，存在一个最佳的项目组规模Popt，这个规模的项目组其总生产率最高。 让我们举例说明项目组规模与生产率的关系。假设个人最高生产率为500LOC/月（即L=500），每条通信路径导致生产率下降10%（即l=50)。如果每个组员都必须与组内所有其他组员通信（r=1)，则项目组规模与生产率的关系列在表13.4（见书304页）中，可见，在这种情况下项目组的最佳规模是5.5人，即Popt=5.5。 事实上，做任何事情都需要时间，我们不可能用“人力换时间”的办法无限缩短一个软件的开发时间。Boehm根据经验指出，软件项目的开发时间最多可以减少到正常开发时间的75%。如果要求一个软件系统的开发时间过短，则开发成功的概率几乎为零。 13.3.2 Gantt图 Gantt（甘特）图是历史悠久、应用广泛的制定进度计划的工具，下面通过一个非常简单的例子介绍这种工具。 假设有一座陈旧的矩形木板房需要重新油漆。这项工作必须分3步完成： 首先刮掉旧漆，然后刷上新漆，最后清除溅在窗户上的油漆。假设一共分配了15名工人去完成这项工作，然而工具却很有限： 只有5把刮旧漆用的刮板，5把刷漆用的刷子，5把清除溅在窗户上的油漆用的小刮刀。怎样安排才能使工作进行得更有效呢? 一种做法是首先刮掉四面墙壁上的旧漆，然后给每面墙壁都刷上新漆，最后清除溅在每个窗户上的油漆。显然这是效率最低的做法，因为总共有15名工人，然而每种工具却只有5件，这样安排工作在任何时候都有10名工人闲着没活干。 读者可能已经想到，应该采用“流水作业法”，也就是说，首先由5名工人用刮板刮掉第1面墙上的旧漆(这时其余10名工人休息)，当第1面墙刮净后，另外5名工人立即用刷子给这面墙刷新漆(与此同时拿刮板的5名工人转去刮第2面墙上的旧漆)，一旦刮旧漆的工人转到第3面墙而且刷新漆的工人转到第2面墙以后，余下的5名工人立即拿起刮刀去清除溅在第1面墙窗户上的油漆，……。这样安排每个工人都有活干，因此能够在较短的时间内完成任务。 假设木板房的第2、4两面墙的长度比第1、3两面墙的长度长一倍，此外，不同工作需要用的时间长短也不同，刷新漆最费时间，其次是刮旧漆，清理(即清除溅在窗户上的油漆)需要的时间最少。表13.5（见书305页）列出了估计每道工序需要用的时间。可以使用图13.1中的Gantt图描绘上述流水作业过程： 在时间为零时开始刮第1面墙上的旧漆，两小时后刮旧漆的工人转去刮第2面墙，同时另5名工人开始给第1面墙刷新漆，每当给一面墙刷完新漆之后，第3组的5名工人立即清除溅在这面墙窗户上的漆。从图13.1可以看出12小时后刮完所有旧漆，20小时后完成所有墙壁的刷漆工作，再过2小时后清理工作结束。因此全部工程在22小时后结束，如果用前述的第一种做法，则需要36小时。 图13.1 旧木板房刷漆工程的Gantt图 13.3.3 工程网络 上一小节介绍的Gantt图能很形象地描绘任务分解情况，以及每个子任务(作业)的开始时间和结束时间，因此是进度计划和进度管理的有力工具。它具有直观简明和容易掌握、容易绘制的优点，但是Gantt图也有3个主要缺点： (1) 不能显式地描绘各项作业彼此间的依赖关系； (2) 进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象； (3) 计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费。 当把一个工程项目分解成许多子任务，并且它们彼此间的依赖关系又比较复杂时，仅仅用Gantt图作为安排进度的工具是不够的，不仅难于做出既节省资源又保证进度的计划，而且还容易发生差错。 工程网络是制定进度计划时另一种常用的图形工具，它同样能描绘任务分解情况以及每项作业的开始时间和结束时间，此外，它还显式地描绘各个作业彼此间的依赖关系。因此，工程网络是系统分析和系统设计的强有力的工具。 在工程网络中用箭头表示作业(例如，刮旧漆，刷新漆，清理等)，用圆圈表示事件(一项作业开始或结束)。注意，事件仅仅是可以明确定义的时间点，它并不消耗时间和资源。作业通常既消耗资源又需要持续一定时间。图13.2是旧木板房刷漆工程的工程网络。图中表示刮第1面墙上旧漆的作业开始于事件1，结束于事件2。用开始事件和结束事件的编号标识一个作业，因此“刮第1面墙上旧漆”是作业1—2。 图13.2 旧木板房刷漆工程的工程网络 在工程网络中的一个事件，如果既有箭头进入又有箭头离开，则它既是某些作业的结束又是另一些作业的开始。例如，图13.2中事件2既是作业1—2(刮第1面墙上的旧漆)的结束，又是作业2—3(刮第2面墙上旧漆)和作业2—4(给第1面墙刷新漆)的开始。也就是说，只有第1面墙上的旧漆刮完之后，才能开始刮第2面墙上旧漆和给第1面墙刷新漆这两个作业。因此，工程网络显式地表示了作业之间的依赖关系。 在图13.2中还有一些虚线箭头，它们表示虚拟作业，也就是事实上并不存在的作业。引入虚拟作业是为了显式地表示作业之间的依赖关系。例如，事件4既是给第1面墙刷新漆结束，又是给第2面墙刷新漆开始(作业4—6)。但是，在开始给第2面墙刷新漆之前，不仅必须已经给第1面墙刷完了新漆，而且第2面墙上的旧漆也必须已经刮净(事件3)。也就是说，在事件3和事件4之间有依赖关系，或者说在作业2—3(刮第2面墙上旧漆)和作业4—6(给第2面墙刷新漆)之间有依赖关系，虚拟作业3—4明确地表示了这种依赖关系。注意，虚拟作业既不消耗资源也不需要时间。 13.3.4 估算工程进度 画出类似图13.2那样的工程网络之后，系统分析员就可以借助它的帮助估算工程进度了。为此需要在工程网络上增加一些必要的信息。 首先，把每个作业估计需要使用的时间写在表示该项作业的箭头上方。注意，箭头长度和它代表的作业持续时间没有关系，箭头仅表示依赖关系，它上方的数字才表示作业的持续时间。 其次，为每个事件计算下述两个统计数字： 最早时刻EET和最迟时刻LET。这两个数字将分别写在表示事件的圆圈的右上角和右下角，如图13.3左下角的符号所示。 事件的最早时刻是该事件可以发生的最早时间。通常工程网络中第一个事件的最早时刻定义为零，其他事件的最早时刻在工程网络上从左至右按事件发生顺序计算。计算最早时刻EET使用下述3条简单规则： 图13.3 旧木板房刷漆工程的完整的工程网络 (1) 考虑进入该事件的所有作业； (2) 对于每个作业都计算它的持续时间与起始事件的EET之和； (3) 选取上述和数中的最大值作为该事件的最早时刻EET。 按照这种方法，不难沿着工程网络从左至右顺序算出每个事件的最早时刻，计算结果标在图13.3的工程网络中(每个圆圈内右上角的数字)。 事件的最迟时刻是在不影响工程竣工时间的前提下，该事件最晚可以发生的时刻。按惯例，最后一个事件(工程结束)的最迟时刻就是它的最早时刻。其他事件的最迟时刻在工程网络上从右至左按逆作业流的方向计算。计算最迟时刻LET使用下述3条规则： (1) 考虑离开该事件的所有作业； (2) 从每个作业的结束事件的最迟时刻中减去该作业的持续时间； (3) 选取上述差数中的最小值作为该事件的最迟时刻LET。 图13.3中每个圆圈内右下角的数字就是该事件的最迟时刻。 13.3.5 关键路径 图13.3中有几个事件的最早时刻和最迟时刻相同，这些事件定义了关键路径，在图中关键路径用粗线箭头表示。关键路径上的事件(关键事件)必须准时发生，组成关键路径的作业(关键作业)的实际持续时间不能超过估计的持续时间，否则工程就不能准时结束。 工程项目的管理人员应该密切注视关键作业的进展情况，如果关键事件出现的时间比预计的时间晚，则会使最终完成项目的时间拖后；如果希望缩短工期，只有往关键作业中增加资源才会有效果。 13.3.6 机动时间 不在关键路径上的作业有一定程度的机动余地——实际开始时间可以比预定时间晚一些，或者实际持续时间可以比预定的持续时间长一些，而并不影响工程的结束时间。一个作业可以有的全部机动时间等于它的结束事件的最迟时刻减去它的开始事件的最早时刻，再减去这个作业的持续时间： 机动时间=(LET)结束-(EET)开始-持续时间 对于前述油漆旧木板房的例子，计算得到的非关键作业的机动时间列在表13.6（见书308页）中。 在工程网络中每个作业的机动时间写在代表该项作业的箭头下面的括弧里(参看图13.3)。 在制定进度计划时仔细考虑和利用工程网络中的机动时间，往往能够安排出既节省资源又不影响最终竣工时间的进度表。在图13.4中的Gantt图描绘了其中的一种方案。 图13.4 旧木板房刷漆工程改进的Gantt图之一 这个简单例子明显说明了工程网络比Gantt图优越的地方： 它显式地定义事件及作业之间的依赖关系，Gantt图只能隐含地表示这种关系。但是Gantt图的形式比工程网络更简单更直观，为更多的人所熟悉，因此，应该同时使用这两种工具制订和管理进度计划，使它们互相补充取长补短。 以上通过旧木板房刷新漆工程的简单例子，介绍了制订进度计划的两个重要工具和方法。软件工程项目虽然比这个简单例子复杂得多，但是计划和管理的基本方法仍然是自顶向下分解，也就是把项目分解为若干个阶段，每个阶段再分解成许多更小的任务，每个任务又可进一步分解为若干个步骤等等。这些阶段、任务和步骤之间有复杂的依赖关系，因此，工程网络和Gantt图同样是安排进度和管理工程进展情况的强有力的工具。 第13.2节中介绍的工作量估计技术可以帮助我们估计每项任务的工作量，根据人力分配情况，可以进一步确定每项任务的持续时间。从这些基本数据出发，根据作业之间的依赖关系，利用工程网络和Gantt图可以制定出合理的进度计划，并且能够科学地管理软件开发工程的进展情况。 13.4 人员组织 软件项目成功的关键是有高素质的软件开发人员。然而大多数软件的规模都很大，单个软件开发人员无法在给定期限内完成开发工作，因此，必须把多名软件开发人员合理地组织起来，使他们有效地分工协作共同完成开发工作。 为了成功地完成软件开发工作，项目组成员必须以一种有意义且有效的方式彼此交互和通信。如何组织项目组是一个重要的管理问题，管理者应该合理地组织项目组，使项目组有较高生产率，能够按预定的进度计划完成所承担的工作。经验表明，项目组组织得越好，其生产率越高，而且产品质量也越好。 除了追求更好的组织方式之外，每个管理者的目标都是建立有凝聚力的项目组。一个有高度凝聚力的小组，由一批团结得非常紧密的人组成，他们的整体力量大于个体力量的总和。一旦项目组具有了凝聚力，成功的可能性就大大增加了。 现有的软件项目组的组织方式很多，通常，组织软件开发人员的方法，取决于所承担的项目的特点、以往的组织经验以及管理者的看法和喜好。下面介绍3种典型的组织方式。 13.4.1 民主制程序员组 民主制程序员组的一个重要特点是，小组成员完全平等，享有充分民主，通过协商做出技术决策。因此，小组成员之间的通信是平行的，如果小组内有n个成员，则可能的通信信道共有n(n-1)/2条。 程序设计小组的人数不能太多,否则组员间彼此通信的时间将多于程序设计时间。此外,通常不能把一个软件系统划分成大量独立的单元,因此,如果程序设计小组人数太多,则每个组员所负责开发的程序单元与系统其他部分的界面将是复杂的,不仅出现接口错误的可能性增加,而且软件测试将既困难又费时间。 一般说来，程序设计小组的规模应该比较小,以2～8名成员为宜。如果项目规模很大,用一个小组不能在预定时间内完成开发任务,则应该使用多个程序设计小组,每个小组承担工程项目的一部分任务，在一定程度上独立自主地完成各自的任务。系统的总体设计应该能够保证由各个小组负责开发的各部分之间的接口是良好定义的,并且是尽可能简单的。 小组规模小,不仅可以减少通信问题,而且还有其他好处。例如,容易确定小组的质量标准,而且用民主方式确定的标准更容易被大家遵守;组员间关系密切,能够互相学习等等。 民主制程序员组通常采用非正式的组织方式，也就是说，虽然名义上有一个组长，但是他和组内其他成员完成同样的任务。在这样的小组中，由全体讨论协商决定应该完成的工作，并且根据每个人的能力和经验分配适当的任务。 民主制程序员组的主要优点是，组员们对发现程序错误持积极的态度，这种态度有助于更快速地发现错误，从而导致高质量的代码。 民主制程序员组的另一个优点是，组员们享有充分民主，小组有高度凝聚力，组内学术空气浓厚，有利于攻克技术难关。因此，当有难题需要解决时，也就是说，当所要开发的软件的技术难度较高时，采用民主制程序员组是适宜的。 如果组内多数成员是经验丰富技术熟练的程序员,那么上述非正式的组织方式可能会非常成功。在这样的小组内组员享有充分民主,通过协商,在自愿的基础上作出决定,因此能够增强团结、提高工作效率。但是,如果组内多数成员技术水平不高,或是缺乏经验的新手,那么这种非正式的组织方式也有严重缺点： 由于没有明确的权威指导开发工程的进行,组员间将缺乏必要的协调,最终可能导致工程失败。 为了使少数经验丰富、技术高超的程序员在软件开发过程中能够发挥更大作用，程序设计小组也可以采用下一小节中介绍的另外一种组织形式。 13.4.2 主程序员组 美国IBM公司在20世纪70年代初期开始采用主程序员组的组织方式。采用这种组织方式主要出于下述几点考虑： (1) 软件开发人员多数比较缺乏经验； (2) 程序设计过程中有许多事务性的工作，例如，大量信息的存储和更新； (3) 多渠道通信很费时间，将降低程序员的生产率。 主程序员组用经验多、技术好、能力强的程序员作为主程序员，同时，利用人和计算机在事务性工作方面给主程序员提供充分支持，而且所有通信都通过一两个人进行。这种组织方式类似于外科手术小组的组织： 主刀大夫对手术全面负责，并且完成制订手术方案、开刀等关键工作，同时又有麻醉师、护士长等技术熟练的专门人员协助和配合他的工作。此外，必要时手术组还要请其他领域的专家（例如，心脏科医生或妇产科医生）协助。 上述比喻突出了主程序员组的两个重要特性： （1） 专业化。该组每名成员仅完成他们受过专业训练的那些工作。 （2） 层次性。主刀大夫指挥每名组员工作，并对手术全面负责。 当时，典型的主程序员组的组织形式如图13.5所示。该组由主程序员、后备程序员、编程秘书以及1~3名程序员组成。在必要的时候，该组还有其他领域的专家协助。 图13.5 主程序员组的结构 主程序员组核心人员的分工如下所述： （1） 主程序员既是成功的管理人员又是经验丰富、技术好、能力强的高级程序员，负责体系结构设计和关键部分（或复杂部分）的详细设计，并且负责指导其他程序员完成详细设计和编码工作。如图13.5所示，程序员之间没有通信渠道，所有接口问题都由主程序员处理。主程序员对每行代码的质量负责，因此，他还要对组内其他成员的工作成果进行复查。 （2） 后备程序员也应该技术熟练而且富于经验，他协助主程序员工作并且在必要时（例如，主程序员生病、出差或“跳槽”）接替主程序员的工作。因此，后备程序员必须在各方面都和主程序员一样优秀，并且对本项目的了解也应该和主程序员一样深入。平时，后备程序员的工作主要是，设计测试方案、分析测试结果及独立于设计过程的其他工作。 （3） 编程秘书负责完成与项目有关的全部事务性工作，例如，维护项目资料库和项目文档，编译、链接、执行源程序和测试用例。 注意，上面介绍的是20世纪70年代初期的主程序员组组织结构，现在的情况已经和当时大不相同了，程序员已经有了自己的终端或工作站，他们自己完成代码的输入、编辑、编译、链接和测试等工作，无须由编程秘书统一做这些工作。典型的主程序员组的现代形式将在下一小节介绍。 虽然图13.5所示的主程序员组的组织方式说起来有不少优点，但是，它在许多方面却是不切实际的。 首先，如前所述，主程序员应该是高级程序员和优秀管理者的结合体。承担主程序员工作需要同时具备这两方面的才能，但是，在现实社会中这样的人才并不多见。通常，既缺乏成功的管理者也缺乏技术熟练的程序员。 其次，后备程序员更难找。人们期望后备程序员像主程序员一样优秀，但是，他们必须坐在“替补席”上，拿着较低的工资等待随时接替主程序员的工作。几乎没有一个高级程序员或高级管理人员愿意接受这样的工作。 第三，编程秘书也很难找到。专业的软件技术人员一般都厌烦日常的事务性工作，但是，人们却期望编程秘书整天只干这类工作。 我们需要一种更合理、更现实的组织程序员组的方法，这种方法应该能充分结合民主制程序员组和主程序员组的优点，并且能用于实现更大规模的软件产品。 13.4.3 现代程序员组 民主制程序员组的一个主要优点，是小组成员都对发现程序错误持积极、主动的态度。但是，使用主程序员组的组织方式时，主程序员对每行代码的质量负责，因此，他必须参与所有代码审查工作。由于主程序员同时又是负责对小组成员进行评价的管理员，他参与代码审查工作就会把所发现的程序错误与小组成员的工作业绩联系起来，从而造成小组成员出现不愿意发现错误的心理。 解决上述问题的方法是，取消主程序员的大部分行政管理工作。前面已经指出，很难找到既是高度熟练的程序员又是成功的管理员的人，取消主程序员的行政管理工作，不仅解决了小组成员不愿意发现程序错误的心理问题，也使得寻找主程序员的人选不再那么困难。于是，实际的“主程序员”应该由两个人共同担任： 一个技术负责人，负责小组的技术活动；一个行政负责人，负责所有非技术性事务的管理决策。这样的组织结构如图13.6所示。技术组长自然要参与全部代码审查工作，因为他要对代码的各方面质量负责；相反，行政组长不可以参与代码审查工作，因为他的职责是对程序员的业绩进行评价。行政组长应该在常规调度会议上了解每名组员的技术能力和工作业绩。 图13.6 现代程序员组的结构 在开始工作之前明确划分技术组长和行政组长的管理权限是很重要的。但是，即使已经做了明确分工，有时也会出现职责不清的矛盾。例如，考虑年度休假问题，行政组长有权批准某个程序员休年假的申请，因为这是一个非技术性问题，但是技术组长可能马上否决了这个申请，因为已经接近预定的项目结束日期，目前人手非常紧张。解决这类问题的办法是求助于更高层的管理人员，对行政组长和技术组长都认为是属于自己职责范围内的事务，制定一个处理方案。 由于程序员组成员人数不宜过多，当软件项目规模较大时，应该把程序员分成若干个小组，采用图13.7所示的组织结构。该图描绘的是技术管理组织结构，非技术管理组织结构与此类似。由图可以看出，产品开发作为一个整体是在项目经理的指导下进行的，程序员向他们的组长汇报工作，而组长则向项目经理汇报工作。当产品规模更大时，可以适当增加中间管理层次。 图13.7 大型项目的技术管理组织结构 把民主制程序员组和主程序员组的优点结合起来的另一种方法，是在合适的地方采用分散做决定的方法，如图13.8所示。这样做有利于形成畅通的通信渠道，以便充分发挥每个程序员的积极性和主动性，集思广益攻克技术难关。这种组织方式对于适合采用民主方法的那类问题（例如，研究性项目或遇到技术难题需要用集体智慧攻关）非常有效。尽管这种组织方式适当地发扬了民主，但是上下级之间的箭头（即管理关系）仍然是向下的，也就是说，是在集中指导下发扬民主。显然，如果程序员可以指挥项目经理，则只会引起混乱。 图13.8 包含分散决策的组织方式 13.5 质量保证 13.5.1 软件质量 概括地说，软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。上述定义强调了下述的3个要点： （1） 软件需求是度量软件质量的基础，与需求不一致就是质量不高。 （2） 指定的开发标准定义了一组指导软件开发的准则，如果没有遵守这些准则，几乎肯定会导致软件质量不高。 （3） 通常，有一组没有显式描述的隐含需求（例如，软件应该是容易维护的）。如果软件满足明确描述的需求，但却不满足隐含的需求，那么软件的质量仍然是值得怀疑的。 虽然软件质量是难于定量度量的软件属性，但是仍然能够提出许多重要的软件质量指标(其中绝大多数目前还处于定性度量阶段)。 本节介绍影响软件质量的主要因素，这些因素是从管理角度对软件质量的度量。可以把这些质量因素分成3组，分别反映用户在使用软件产品时的3种不同倾向或观点。这3种倾向是： 产品运行、产品修改和产品转移。图13.9描绘了软件质量因素和上述3种倾向(或产品活动)之间的关系，表13.7（见书315页）列出了软件质量因素的简明定义。 图13.9 软件质量因素与产品活动的关系 13.5.2 软件质量保证措施 软件质量保证（software quality assurance,SQA）的措施主要有： 基于非执行的测试（也称为复审或评审），基于执行的测试（即以前讲过的软件测试）和程序正确性证明。复审主要用来保证在编码之前各阶段产生的文档的质量；基于执行的测试需要在程序编写出来之后进行，它是保证软件质量的最后一道防线；程序正确性证明使用数学方法严格验证程序是否与对它的说明完全一致。 参加软件质量保证工作的人员，可以划分成下述两类： 软件工程师通过采用先进的技术方法和度量，进行正式的技术复审以及完成计划周密的软件测试来保证软件质量。 SQA小组的职责，是辅助软件工程师以获得高质量的软件产品。其从事的软件质量保证活动主要是： 计划，监督，记录，分析和报告。简而言之，SQA小组的作用是，通过确保软件过程的质量来保证软件产品的质量。 \\1. 技术复审的必要性 正式技术复审的显著优点是，能够较早发现软件错误，从而可防止错误被传播到软件过程的后续阶段。 统计数字表明，在大型软件产品中检测出的错误，60%~70%属于规格说明错误或设计错误，而正式技术复审在发现规格说明错误和设计错误方面的有效性高达75%。由于能够检测出并排除掉绝大部分这类错误，复审可大大降低后续开发和维护阶段的成本。 实际上，正式技术复审是软件质量保证措施的一种，包括走查（walkthrough)和审查（inspection）等具体方法。走查的步骤比审查少，而且没有审查正规。 \\2. 走查 走查组由4~6名成员组成。以走查规格说明的小组为例，成员至少包括一名负责起草规格说明的人，一名负责该规格说明的管理员，一位客户代表，以及下阶段开发组（在本例中是设计组）的一名代表和SQA小组的一名代表。其中SQA小组的代表应该作为走查组的组长。 为了能发现重大错误，走查组成员最好是经验丰富的高级技术人员。必须把被走查的材料预先分发给走查组每位成员。走查组成员应该仔细研究材料并列出两张表： 一张表是他不理解的术语，另一张是他认为不正确的术语。 走查组组长引导该组成员走查文档，力求发现尽可能多的错误。走查组的任务仅仅是标记出错误而不是改正错误，改正错误的工作应该由该文档的编写组完成。走查的时间最长不要超过2小时，这段时间应该用来发现和标记错误，而不是改正错误。 走查主要有下述两种方式： （1） 参与者驱动法。参与者按照事先准备好的列表，提出他们不理解的术语和认为不正确的术语。文档编写组的代表必须回答每个质疑，要么承认确实有错误，要么对质疑做出解释。 （2） 文档驱动法。文档编写者向走查组成员仔细解释文档。走查组成员在此过程中不时针对事先准备好的问题或解释过程中发现的问题提出质疑。这种方法可能比第一种方法更有效，往往能检测出更多错误。经验表明，使用文档驱动法时许多错误是由文档讲解者自己发现的。 \\3. 审查 审查的范围比走查广泛得多，它的步骤也比较多。通常，审查过程包括下述5个基本步骤： （1） 综述。由负责编写文档的一名成员向审查组综述该文档。在综述会结束时把文档分发给每位与会者。 （2） 准备。评审员仔细阅读文档。最好列出在审查中发现的错误的类型，并按发生频率把错误类型分级，以辅助审查工作。这些列表有助于评审员们把注意力集中到最常发生错误的区域。 （3） 审查。评审组仔细走查整个文档。和走查一样，这一步的目的也是发现文档中的错误，而不是改正它们。通常每次审查会不超过90分钟。审查组组长应该在一天之内写出一份关于审查的报告。 （4） 返工。文档的作者负责解决在审查报告中列出的所有错误及问题。 （5） 跟踪。组长必须确保所提出的每个问题都得到了圆满的解决（要么修正了文档，要么澄清了被误认为是错误的条目）。必须仔细检查对文档所做的每个修正，以确保没有引入新的错误。如果在审查过程中返工量超过5%，则应该由审查组再对文档全面地审查一遍。 通常，审查组由4人组成。组长既是审查组的管理人员又是技术负责人。审查组必须包括负责当前阶段开发工作的项目组代表和负责下一阶段开发工作的项目组代表，此外，还应该包括一名SQA小组的代表。 审查过程不仅步数比走查多，而且每个步骤都是正规的。审查的正规性体现在： 仔细划分错误类型，并把这些信息运用在后续阶段的文档审查中以及未来产品的审查中。 审查是检测软件错误的一种好方法，利用审查可以在软件过程的早期阶段发现并改正错误，也就是说，能在修正错误的代价变得很昂贵之前就发现并改正错误。因此，审查是一种经济有效的错误检测方法。 \\4. 程序正确性证明 测试可以暴露程序中的错误，因此是保证软件可靠性的重要手段；但是，测试只能证明程序中有错误，并不能证明程序中没有错误。因此，对于保证软件可靠性来说，测试是一种不完善的技术，人们自然希望研究出完善的正确性证明技术。一旦研究出实用的正确性证明程序(即，能自动证明其他程序的正确性的程序)，软件可靠性将更有保证，测试工作量将大大减少。但是，即使有了正确性证明程序，软件测试也仍然是需要的，因为程序正确性证明只证明程序功能是正确的，并不能证明程序的动态特性是符合要求的，此外，正确性证明过程本身也可能发生错误。 正确性证明的基本思想是证明程序能完成预定的功能。因此，应该提供对程序功能的严格数学说明，然后根据程序代码证明程序确实能实现它的功能说明。 在20世纪60年代初期，人们已经开始研究程序正确性证明的技术，提出了许多不同的技术方法。虽然这些技术方法本身很复杂，但是它们的基本原理却是相当简单的。 如果在程序的若干个点上，设计者可以提出关于程序变量及它们的关系的断言，那么在每一点上的断言都应该永远是真的。假设在程序的P1,P2,…，Pn等点上的断言分别是a(1),a(2)，…，a(n)，其中a(1)必须是关于程序输入的断言，a(n)必须是关于程序输出的断言。 为了证明在点Pi和Pi+1之间的程序语句是正确的，必须证明执行这些语句之后将使断言a(i)变成a(i+1)。如果对程序内所有相邻点都能完成上述证明过程，则证明了输入断言加上程序可以导出输出断言。如果输入断言和输出断言是正确的，而且程序确实是可以终止的(不包含死循环)，则上述过程就证明了程序的正确性。 人工证明程序正确性，对于评价小程序可能有些价值，但是在证明大型软件的正确性时，不仅工作量太大，更主要的是在证明的过程中很容易包含错误，因此是不实用的。为了实用的目的，必须研究能证明程序正确性的自动系统。 目前已经研究出证明PASCAL和LISP程序正确性的程序系统，正在对这些系统进行评价和改进。现在这些系统还只能对较小的程序进行评价，毫无疑问还需要做许多工作，这样的系统才能实际用于大型程序的正确性证明。 13.6 软件配置管理 任何软件开发都是迭代过程，也就是说，在设计过程会发现需求说明书中的问题，在实现过程又会暴露出设计中的错误。此外，随着时间推移客户的需求也会或多或少发生变化。因此，在开发软件的过程中，变化（或称为变动）既是必要的，又是不可避免的。但是，变化也很容易失去控制，如果不能适当地控制和管理变化，势必造成混乱并产生许多严重的错误。 软件配置管理是在软件的整个生命期内管理变化的一组活动。具体地说，这组活动用来： ①标识变化； ②控制变化； ③确保适当地实现了变化； ④向需要知道这类信息的人报告变化。 软件配置管理不同于软件维护。维护是在软件交付给用户使用后才发生的，而配置管理是在软件项目启动时就开始，并且一直持续到软件退役后才终止的一组跟踪和控制活动。 软件配置管理的目标是，使变化更正确且更容易被适应，在必须变化时减少所需花费的工作量。 13.6.1 软件配置 1. 软件配置项 软件过程的输出信息可以分为3类： ①计算机程序（源代码和可执行程序）； ②描述计算机程序的文档（供技术人员或用户使用）； ③数据（程序内包含的或在程序外的）。 上述这些项组成了在软件过程中产生的全部信息，我们把它们统称为软件配置，而这些项就是软件配置项。 随着软件开发过程的进展，软件配置项的数量迅速增加。不幸的是，由于前述的种种原因，软件配置项的内容随时都可能发生变化。为了开发出高质量的软件产品，软件开发人员不仅要努力保证每个软件配置项正确，而且必须保证一个软件的所有配置项是完全一致的。 可以把软件配置管理看作是应用于整个软件过程的软件质量保证活动，是专门用于管理变化的软件质量保证活动。 2. 基线 基线是一个软件配置管理概念，它有助于我们在不严重妨碍合理变化的前提下来控制变化。IEEE把基线定义为： 已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它。 简而言之，基线就是通过了正式复审的软件配置项。在软件配置项变成基线之前，可以迅速而非正式地修改它。一旦建立了基线之后，虽然仍然可以实现变化，但是，必须应用特定的、正式的过程（称为规程）来评估、实现和验证每个变化。 除了软件配置项之外，许多软件工程组织也把软件工具置于配置管理之下，也就是说，把特定版本的编辑器、编译器和其他CASE工具，作为软件配置的一部分“固定”下来。因为当修改软件配置项时必然要用到这些工具，为防止不同版本的工具产生的结果不同，应该把软件工具也基线化，并且列入到综合的配置管理过程之中。 13.6.2 软件配置管理过程 软件配置管理是软件质量保证的重要一环，它的主要任务是控制变化，同时也负责各个软件配置项和软件各种版本的标识、软件配置审计以及对软件配置发生的任何变化的报告。 具体来说，软件配置管理主要有5项任务： 标识、版本控制、变化控制、配置审计和报告。 1. 标识软件配置中的对象 为了控制和管理软件配置项，必须单独命名每个配置项，然后用面向对象方法组织它们。可以标识出两类对象： 基本对象和聚集对象（可以把聚集对象作为代表软件配置完整版本的一种机制）。基本对象是软件工程师在分析、设计、编码或测试过程中创建出来的“文本单元”，例如，需求规格说明的一个段落、一个模块的源程序清单或一组测试用例。聚集对象是基本对象和其他聚集对象的集合。 每个对象都有一组能惟一地标识它的特征： 名字、描述、资源表和“实现”。其中，对象名是无二义性地标识该对象的一个字符串。 在设计标识软件对象的模式时，必须认识到对象在整个生命周期中一直都在演化，因此，所设计的标识模式必须能无歧义地标识每个对象的不同版本。 2. 版本控制 版本控制联合使用规程和工具，以管理在软件工程过程中所创建的配置对象的不同版本。借助于版本控制技术，用户能够通过选择适当的版本来指定软件系统的配置。实现这个目标的方法是，把属性和软件的每个版本关联起来，然后通过描述一组所期望的属性来指定和构造所需要的配置。 上面提到的“属性”，既可以简单到仅是赋给每个配置对象的具体版本号，也可以复杂到是一个布尔变量串，其指明了施加到系统上的功能变化的具体类型。 非发行版本，只要变化的版本，每一版不能覆盖 3. 变化控制 对于大型软件开发项目来说，无控制的变化将迅速导致混乱。变化控制把人的规程和自动工具结合起来，以提供一个控制变化的机制。典型的变化控制过程如下： 接到变化请求之后，首先评估该变化在技术方面的得失、可能产生的副作用、对其他配置对象和系统功能的整体影响以及估算出的修改成本。评估的结果形成“变化报告”，该报告供“变化控制审批者”审阅。所谓变化控制审批者既可以是一个人也可以由一组人组成，其对变化的状态和优先级做最终决策。 为每个被批准的变化都生成一个“工程变化命令”，其描述将要实现的变化，必须遵守的约束以及复审和审计的标准。把要修改的对象从项目数据库中“提取（check out）”出来【给迁出项目对象加锁，其他人不能修改】，进行修改并应用适当的SQA活动。最后，把修改后的对象“提交（check in）”进数据库【解锁，其他人可以修改】，并用适当的版本控制机制创建该软件的下一个版本。 “提交”和“提取”过程实现了变化控制的两个主要功能——访问控制和同步控制。访问控制决定哪个软件工程师有权访问和修改一个特定的配置对象，同步控制有助于保证由两名不同的软件工程师完成的并行修改不会相互覆盖。 在一个软件配置项变成基线之前，仅需应用非正式的变化控制。该配置对象的开发者可以对它进行任何合理的修改（只要修改不会影响到开发者工作范围之外的系统需求）。一旦该对象经过了正式技术复审并获得批准，就创建了一个基线。而一旦一个软件配置项变成了基线，就开始实施项目级的变化控制。现在，为了进行修改开发者必须获得项目管理者的批准（如果变化是“局部的”），如果变化影响到其他软件配置项，还必须得到变化控制审批者的批准。在某些情况下，可以省略正式的变化请求、变化报告和工程变化命令，但是，必须评估每个变化并且跟踪和复审所有变化。 \\4. 配置审计 为了确保适当地实现了所需要的变化，通常从下述两方面采取措施： ①正式的技术复审； ②软件配置审计。 正式的技术复审（见13.5.2节）关注被修改后的配置对象的技术正确性。复审者审查该对象以确定它与其他软件配置项的一致性，并检查是否有遗漏或副作用。 软件配置审计通过评估配置对象的那些通常不在复审过程中考虑的特征（例如，修改时是否遵循了软件工程标准，是否在该配置项中显著地标明了所做的修改，是否注明了修改日期和修改者，是否适当地更新了所有相关的软件配置项，是否遵循了标注变化、记录变化和报告变化的规程），而成为对正式技术复审的补充。 \\5. 状态报告 书写配置状态报告是软件配置管理的一项任务，它回答下述问题： ①发生了什么事？ ②谁做的这件事？③这件事是什么时候发生的？④它将影响哪些其他事物？ 配置状态变化对大型软件开发项目的成功有重大影响。当大量人员在一起工作时，可能一个人并不知道另一个人在做什么。两名开发人员可能试图按照相互冲突的想法去修改同一个软件配置项；软件工程队伍可能耗费几个人月的工作量根据过时的硬件规格说明开发软件；察觉到所建议的修改有严重副作用的人可能还不知道该项修改正在进行。配置状态报告通过改善所有相关人员之间的通信，帮助消除这些问题。 13.7 能力成熟度模型 美国卡内基梅隆大学软件工程研究所在美国国防部资助下于20世纪80年代末建立的能力成熟度模型（capability maturity model，CMM)，是用于评价软件机构的软件过程能力成熟度的模型。最初，建立此模型的目的主要是，为大型软件项目的招投标活动提供一种全面而客观的评审依据，发展到后来，此模型又同时被应用于许多软件机构内部的过程改进活动中。 多年来，软件危机一直困扰着许多软件开发机构。不少人试图通过采用新的软件开发技术来解决在软件生产率和软件质量等方面存在的问题，但效果并不令人十分满意。上述事实促使人们进一步考察软件过程，从而发现关键问题在于对软件过程的管理不尽人意。事实证明，在无规则和混乱的管理之下，先进的技术和工具并不能发挥出应有的作用。人们逐渐认识到，改进对软件过程的管理是消除软件危机的突破口，再也不能忽视在软件过程中管理的关键作用了。 能力成熟度模型的基本思想是，由于问题是由我们管理软件过程的方法不当引起的，所以新软件技术的运用并不会自动提高软件的生产率和质量。能力成熟度模型有助于软件开发机构建立一个有规律的、成熟的软件过程。改进后的软件过程将开发出质量更好的软件，使更多的软件项目免受时间和费用超支之苦。 软件过程包括各种活动、技术和工具，因此，它实际上既包括了软件开发的技术方面又包括了管理方面。CMM的策略是，力图改进对软件过程的管理，而在技术方面的改进是其必然的结果。 CMM在改进软件过程中所起的作用主要是，指导软件机构通过确定当前的过程成熟度并识别出对过程改进起关键作用的问题，从而明确过程改进的方向和策略。通过集中开展与过程改进的方向和策略相一致的一组过程改进活动，软件机构便能稳步而有效地改进其软件过程，使其软件过程能力得到循序渐进的提高。 对软件过程的改进，是在完成一个又一个小的改进步骤基础上不断进行的渐进过程，而不是一蹴而就的彻底革命。CMM把软件过程从无序到有序的进化过程分成5个阶段，并把这些阶段排序，形成5个逐层提高的等级。这5个成熟度等级定义了一个有序的尺度，用以测量软件机构的软件过程成熟度和评价其软件过程能力，这些等级还能帮助软件机构把应做的改进工作排出优先次序。成熟度等级是妥善定义的向成熟软件机构前进途中的平台，每个成熟度等级都为软件过程的继续改进提供了一个台阶。 CMM对5个成熟度级别特性的描述，说明了不同级别之间软件过程的主要变化。从“1级”到“5级”，反映出一个软件机构为了达到从一个无序的、混乱的软件过程进化到一种有序的、有纪律的且成熟的软件过程的目的，必须经历的过程改进活动的途径。每一个成熟度级别都是该软件机构沿着改进其过程的途径前进途中的一个台阶，后一个成熟度级别是前一个级别的软件过程的进化目标。 CMM的每个成熟度级别中都包含一组过程改进的目标，满足这些目标后一个机构的软件过程就从当前级别进化到下一个成熟度级别；每达到成熟度级别框架的下一个级别，该机构的软件过程都得到一定程度的完善和优化，也使得过程能力得到提高；随着成熟度级别的不断提高，该机构的过程改进活动取得了更加显著的成效，从而使软件过程得到进一步的完善和优化。CMM就是以上述方式支持软件机构改进其软件过程的活动。 CMM通过定义能力成熟度的5个等级，引导软件开发机构不断识别出其软件过程的缺陷，并指出应该做哪些改进，但是，它并不提供做这些改进的具体措施。 能力成熟度的5个等级从低到高依次是： 初始级（又称为1级），可重复级（又称为2级），已定义级（又称为3级），已管理级（又称为4级）和优化级（又称为5级）。下面介绍这5个级别的特点。 1. 初始级 软件过程的特征是无序的，有时甚至是混乱的。几乎没有什么过程是经过定义的（即没有一个定型的过程模型），项目能否成功完全取决于开发人员的个人能力。 处于这个最低成熟度等级的软件机构，基本上没有健全的软件工程管理制度，其软件过程完全取决于项目组的人员配备，所以具有不可预测性，人员变了过程也随之改变。如果一个项目碰巧由一个杰出的管理者和一支有经验、有能力的开发队伍承担，则这个项目可能是成功的。但是，更常见的情况是，由于缺乏健全的管理和周密的计划，延期交付和费用超支的情况经常发生，结果，大多数行动只是应付危机，而不是完成事先计划好的任务。 总之，处于1级成熟度的软件机构，其过程能力是不可预测的，其软件过程是不稳定的，产品质量只能根据相关人员的个人工作能力而不是软件机构的过程能力来预测。 2. 可重复级 软件机构建立了基本的项目管理过程(过程模型),可跟踪成本、进度、功能和质量。已经建立起必要的过程规范，对新项目的策划和管理过程是基于以前类似项目的实践经验，使得有类似应用经验的软件项目能够再次取得成功。达到2级的一个目标是使项目管理过程稳定，从而使得软件机构能重复以前在成功项目中所进行过的软件项目工程实践。 处于2级成熟度的软件机构，针对所承担的软件项目已建立了基本的软件管理控制制度。通过对以前项目的观察和分析，可以提出针对现行项目的约束条件。项目负责人跟踪软件产品开发的成本和进度以及产品的功能和质量，并且识别出为满足约束条件所应解决的问题。已经做到软件需求条理化，而且其完整性是受控制的。已经制定了项目标准，并且软件机构能确保严格执行这些标准。项目组与客户及承包商已经建立起一个稳定的、可管理的工作环境。 处于2级成熟度的软件机构的过程能力可以概括为，软件项目的策划和跟踪是稳定的，已经为一个有纪律的管理过程提供了可重复以前成功实践的项目环境。软件项目工程活动处于项目管理体系的有效控制之下，执行着基于以前项目的准则且合乎现实的计划。 3. 已定义级 软件机构已经定义了完整的软件过程（过程模型），软件过程已经文档化和标准化。所有项目组都使用文档化的、经过批准的过程来开发和维护软件。这一级包含了第2级的全部特征。 在第3级成熟度的软件机构中，有一个固定的过程小组从事软件过程工程活动。当需要时，过程小组可以利用过程模型进行过程例化活动，从而获得一个针对某个特定的软件项目的过程实例，并投入过程运作而开展有效的软件项目工程实践。同时，过程小组还可以推进软件机构的过程改进活动。在该软件机构内实施了培训计划，能够保证全体项目负责人和项目开发人员具有完成承担的任务所要求的知识和技能。 处于3级成熟度的软件机构的过程能力可以概括为，无论是管理活动还是工程活动都是稳定的。软件开发的成本和进度以及产品的功能和质量都受到控制，而且软件产品的质量具有可追溯性。这种能力是基于在软件机构中对已定义的过程模型的活动、人员和职责都有共同的理解。 4. 已管理级 软件机构对软件过程（过程模型和过程实例）和软件产品都建立了定量的质量目标，所有项目的重要的过程活动都是可度量的。该软件机构收集了过程度量和产品度量的方法并加以运用，可以定量地了解和控制软件过程和软件产品，并为评定项目的过程质量和产品质量奠定了基础。这一级包含了第3级的全部特征。 处于4级成熟度的软件机构的过程能力可以概括为，软件过程是可度量的，软件过程在可度量的范围内运行。这一级的过程能力允许软件机构在定量的范围内预测过程和产品质量趋势，在发生偏离时可以及时采取措施予以纠正，并且可以预期软件产品是高质量的。 5. 优化级 软件机构集中精力持续不断地改进软件过程。这一级的软件机构是一个以防止出现缺陷为目标的机构，它有能力识别软件过程要素的薄弱环节，并有足够的手段改进它们。在这样的机构中，可以获得关于软件过程有效性的统计数据，利用这些数据可以对新技术进行成本/效益分析，并可以优化出在软件工程实践中能够采用的最佳新技术。这一级包含了第4级的全部特征。 这一级的软件机构可以通过对过程实例性能的分析和确定产生某一缺陷的原因，来防止再次出现这种类型的缺陷；通过对任何一个过程实例的分析所获得的经验教训都可以成为该软件机构优化其过程模型的有效依据，从而使其他项目的过程实例得到优化。这样的软件机构可以通过从过程实施中获得的定量的反馈信息，在采用新思想和新技术的同时测试它们，以不断地改进和优化软件过程。 处于5级成熟度的软件机构的过程能力可以概括为，软件过程是可优化的。这一级的软件机构能够持续不断地改进其过程能力，既对现行的过程实例不断地改进和优化，又借助于所采用的新技术和新方法来实现未来的过程改进。 一些统计数字表明，提高一个完整的成熟度等级大约需要花18个月到3年的时间，但是从第1级上升到第2级有时要花3年甚至5年时间。这说明要向一个迄今仍处于混乱的和被动的行动方式的软件机构灌输系统化的方式，将多么困难。 13.8 小结 软件工程包括技术和管理两方面的内容，是技术与管理紧密结合的产物。只有在科学而严格的管理之下，先进的技术方法和优秀的软件工具才能真正发挥出威力。因此，有效的管理是大型软件工程项目成功的关键。 软件项目管理始于项目计划，而第一项计划活动就是估算。为了估算项目工作量和完成期限，首先需要预测软件规模。 度量软件规模的常用技术主要有代码行技术和功能点技术。这两种技术各有优缺点，应该根据项目特点及从事计划工作的人对这两种技术的熟悉程度，选用适用的技术。 根据软件规模可以估算出完成该项目所需的工作量，常用的估算模型为静态单变量模型、动态多变量模型和COCOMO2模型。为了使估算结果更接近实际值，通常至少同时使用上述3种模型中的两种。通过比较和协调使用不同模型得出的估算值，有可能得到比较准确的估算结果。成本估算模型通常也同时提供了估算软件开发时间的方程式，这样估算出的开发时间是正常开发时间，经验表明，用增加开发人员的方法最多可以把开发时间减少到正常开发时间的75%。 管理者必须制定出一个足够详细的进度表，以便监督项目进度并控制整个项目。常用的制定进度计划的工具有Gantt图和工程网络，这两种工具各有优缺点，通常，联合使用Gantt图和工程网络来制定进度计划并监督项目进展状况。 高素质的开发人员和合理的项目组组织结构，是软件项目取得成功的关键。比较典型的组织结构有民主制程序员组、主程序员组和现代程序员组等3种，这3种组织方式的适用场合并不相同。 软件质量保证是在软件过程中的每一步都进行的活动。软件质量保证措施主要有基于非执行的测试（也称为复审）、基于执行的测试（即通常所说的测试）和程序正确性证明。软件复审是最重要的软件质量保证活动之一，它的优点是在改正错误的成本相对比较低时就能及时发现并排除软件错误。 软件配置管理是应用于整个软件过程中的保护性活动，是在软件整个生命期内管理变化的一组活动。软件配置管理的目标是，使变化能够更正确且更容易被适应，在需要修改软件时减少为此而花费的工作量。 能力成熟度模型（CMM）是改进软件过程的有效策略。它的基本思想是，因为问题是管理软件过程的方法不恰当造成的，所以采用新技术并不会自动提高软件生产率和软件质量，应该下大力气改进对软件过程的管理。事实上对软件过程的改进不可能一蹴而就，因此，CMM以增量方式逐步引入变化，它明确地定义了5个成熟度等级，一个软件开发组织可以用一系列小的改良性步骤迈入更高的成熟度等级。 "},"page/1021.html":{"url":"page/1021.html","title":"面向对象","keywords":"","body":"面向对象 "}}